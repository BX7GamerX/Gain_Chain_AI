import { SignerAgent } from '@slide-computer/signer-agent';
export { SignerAgent, SignerAgentOptions } from '@slide-computer/signer-agent';
import { HttpAgent, Identity, Agent as Agent$1, SignIdentity } from '@dfinity/agent';
import { Signer } from '@slide-computer/signer';
export { fromBase64, toBase64 } from '@slide-computer/signer';
import * as _dfinity_identity from '@dfinity/identity';
import { Delegation, PartialIdentity } from '@dfinity/identity';
import { SignerStorage } from '@slide-computer/signer-storage';
import { AuthClientStorage } from '@dfinity/auth-client';
import { SubAccount } from '@dfinity/ledger-icp';
import { Principal } from '@dfinity/principal';

type AgentOptions = {
    delegation?: Delegation;
    signerAgent: SignerAgent<Signer>;
    agent: HttpAgent;
    identity?: Identity | PartialIdentity;
};
declare class Agent implements Agent$1 {
    private signerAgentStrategy;
    private agentStrategy;
    private delegation?;
    private constructor();
    static create({ delegation, signerAgent, agent }: AgentOptions): Promise<Agent>;
    call(...params: Parameters<Agent$1["call"]>): ReturnType<Agent$1["call"]>;
    query(...params: Parameters<Agent$1["query"]>): ReturnType<Agent$1["query"]>;
    get rootKey(): ArrayBuffer | null;
    fetchRootKey(): ReturnType<Agent$1["fetchRootKey"]>;
    getPrincipal(): ReturnType<Agent$1["getPrincipal"]>;
    status(): ReturnType<Agent$1["status"]>;
    readState(...params: Parameters<Agent$1["readState"]>): ReturnType<Agent$1["readState"]>;
    createReadStateRequest?(): Promise<any>;
}

/** @module IdleManager */
type TimeoutCB = () => unknown;
type TimeoutManagerOptions = {
    /**
     * Callback after the timeout
     */
    onTimeout?: TimeoutCB;
    /**
     * timeout in ms
     */
    timeout: number;
};
/**
 * Detects if the `timeout` ms is over, and calls `onTimeout` and registered callbacks.
 * To override these defaults, you can pass an `onTimeout` callback, or configure a custom `timeout` in milliseconds
 */
declare class TimeoutManager {
    callbacks: TimeoutCB[];
    timeout?: TimeoutManagerOptions["timeout"];
    timeoutID?: number;
    /**
     * @param options {@link IdleManagerOptions}
     */
    constructor(options: TimeoutManagerOptions);
    /**
     * @param {TimeoutCB} callback function to be called on timeout
     */
    registerCallback(callback: TimeoutCB): void;
    /**
     * Cleans up the timeout manager and its listeners
     */
    exit(): void;
    /**
     * Resets the timeouts during cleanup
     */
    _resetTimer(): void;
}

type IdleManagerOptions = {
    /**
     * capture scroll events
     * @default false
     */
    captureScroll?: boolean;
    /**
     * scroll debounce time in ms
     * @default 100
     */
    scrollDebounce?: number;
    /**
     * Callback after the user has gone idle
     */
    onIdle?: () => unknown;
    /**
     * timeout in ms
     */
    idleTimeout?: number;
};
/**
 * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.
 * By default, the IdleManager will log a user out after 10 minutes of inactivity.
 * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds
 */
declare class IdleManager extends TimeoutManager {
    constructor(options?: IdleManagerOptions);
}

interface IdleOptions extends IdleManagerOptions {
    /**
     * Disables idle functionality for {@link IdleManager}
     * @default false
     */
    disableIdle?: boolean;
    /**
     * Disables default idle behavior - call logout
     * @default false
     */
    disableDefaultIdleCallback?: boolean;
}
interface SignerClientOptions {
    signer: Signer;
    /**
     * Optional, used to generate random bytes
     * @default uses browser/node Crypto by default
     */
    crypto?: Pick<Crypto, "getRandomValues" | "randomUUID">;
    /**
     * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default
     */
    storage?: AuthClientStorage;
    /**
     * Options to handle idle timeouts
     * @default after 30 minutes, invalidates the identity
     */
    idleOptions?: IdleOptions;
    derivationOrigin?: string;
    onLogout?: () => Promise<unknown>;
}
declare abstract class SignerClient {
    protected options: SignerClientOptions;
    protected idleManager: IdleManager | undefined;
    protected storage: SignerStorage;
    connectedUser: {
        principal: Principal;
        subAccount?: SubAccount;
    } | undefined;
    constructor(options: SignerClientOptions);
    protected registerDefaultIdleCallback(): void;
    protected logout(options?: {
        returnTo?: string;
    }): Promise<void>;
    protected setConnectedUser(user: {
        owner: string;
        subAccount?: ArrayBuffer;
    } | undefined): Promise<void>;
    protected setConnectedUserToStorage(user: {
        owner: string;
        subAccount?: ArrayBuffer;
    } | undefined): Promise<void>;
    static shouldCheckIsUserConnected(): boolean;
    protected getConnectedUserFromStorage(): Promise<{
        owner: string;
        subAccount?: ArrayBuffer;
    } | undefined>;
    protected get crypto(): Pick<Crypto, "getRandomValues" | "randomUUID">;
}

declare const ED25519_KEY_LABEL = "Ed25519";
type BaseKeyType = "ECDSA" | typeof ED25519_KEY_LABEL;
declare enum DelegationType {
    ACCOUNT = "ACCOUNT",
    RELYING_PARTY = "RELYING_PARTY"
}
interface DelegationSignerClientOptions extends SignerClientOptions {
    /**
     * An identity to use as the base
     */
    identity?: SignIdentity | PartialIdentity;
    /**
     * type to use for the base key
     * @default 'ECDSA'
     * If you are using a custom storage provider that does not support CryptoKey storage,
     * you should use 'Ed25519' as the key type, as it can serialize to a string
     */
    keyType?: BaseKeyType;
    targets?: string[];
    /**
     * Expiration of the delegation in nanoseconds
     */
    maxTimeToLive?: bigint;
}
declare class DelegationSignerClient extends SignerClient {
    private identity;
    private baseIdentity;
    private targets?;
    private maxTimeToLive;
    private expirationManager?;
    constructor(options: SignerClientOptions, identity: Identity | PartialIdentity, baseIdentity: SignIdentity | PartialIdentity, targets?: string[] | undefined, maxTimeToLive?: bigint);
    static create(options: DelegationSignerClientOptions): Promise<DelegationSignerClient>;
    private static createIdentity;
    login(): Promise<void>;
    private initExpirationManager;
    logout(options?: {
        returnTo?: string;
    }): Promise<void>;
    getIdentity(): Identity | PartialIdentity;
    getDelegationType(): Promise<DelegationType>;
    getDelegation(): Promise<_dfinity_identity.SignedDelegation | undefined>;
}

interface AccountsSignerClientOptions extends SignerClientOptions {
}
declare class AccountsSignerClient extends SignerClient {
    static create(options: AccountsSignerClientOptions): Promise<AccountsSignerClient>;
    login(): Promise<void>;
    logout(options?: {
        returnTo?: string;
    }): Promise<void>;
    private setAccounts;
    getAccounts(): Promise<{
        principal: Principal;
        subAccount?: SubAccount;
    }[] | undefined>;
}

type ObjectValuesType<T> = T[keyof T];
declare const IdentityKitAuthType: {
    readonly DELEGATION: "DELEGATION";
    readonly ACCOUNTS: "ACCOUNTS";
};
type IdentityKitAuthType = ObjectValuesType<typeof IdentityKitAuthType>;
declare class IdentityKit<T extends IdentityKitAuthType = typeof IdentityKitAuthType.ACCOUNTS, TSignerClient = T extends typeof IdentityKitAuthType.DELEGATION ? DelegationSignerClient : AccountsSignerClient> {
    signerClient: TSignerClient;
    constructor(signerClient: TSignerClient);
    getIcpBalance(): Promise<number>;
    static create<T extends IdentityKitAuthType = typeof IdentityKitAuthType.ACCOUNTS, TSignerClientOptions = T extends typeof IdentityKitAuthType.DELEGATION ? DelegationSignerClientOptions : AccountsSignerClientOptions>({ signerClientOptions, authType }: {
        signerClientOptions: TSignerClientOptions;
        authType: T;
    }): Promise<IdentityKit<"ACCOUNTS", DelegationSignerClient> | IdentityKit<"ACCOUNTS", AccountsSignerClient>>;
}

type SignerConfig = {
    id: string;
    providerUrl: string;
    label: string;
    transportType: TransportType;
    icon?: string;
    description?: string;
};
declare enum TransportType {
    NEW_TAB = 0,
    EXTENSION = 1,
    INTERNET_IDENTITY = 2,
    STOIC = 3,
    PLUG = 4
}

declare const NFIDW: SignerConfig;
declare const MockedSigner: SignerConfig;
declare const Plug: SignerConfig;
declare const InternetIdentity: SignerConfig;
declare const Stoic: SignerConfig;
declare const OISY: SignerConfig;

export { IdentityKit, AccountsSignerClient as IdentityKitAccountsSignerClient, type AccountsSignerClientOptions as IdentityKitAccountsSignerClientOptions, Agent as IdentityKitAgent, type AgentOptions as IdentityKitAgentOptions, IdentityKitAuthType, DelegationSignerClient as IdentityKitDelegationSignerClient, type DelegationSignerClientOptions as IdentityKitDelegationSignerClientOptions, DelegationType as IdentityKitDelegationType, SignerClient as IdentityKitSignerClient, type SignerClientOptions as IdentityKitSignerClientOptions, type SignerConfig as IdentityKitSignerConfig, TransportType as IdentityKitTransportType, InternetIdentity, MockedSigner, NFIDW, OISY, Plug, Stoic };
