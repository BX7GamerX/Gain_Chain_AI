import { type Identity, type SignIdentity } from "@dfinity/agent";
import { PartialIdentity } from "@dfinity/identity";
import { SignerClient, SignerClientOptions } from "./client";
declare const ED25519_KEY_LABEL = "Ed25519";
type BaseKeyType = "ECDSA" | typeof ED25519_KEY_LABEL;
export declare enum DelegationType {
    ACCOUNT = "ACCOUNT",
    RELYING_PARTY = "RELYING_PARTY"
}
export interface DelegationSignerClientOptions extends SignerClientOptions {
    /**
     * An identity to use as the base
     */
    identity?: SignIdentity | PartialIdentity;
    /**
     * type to use for the base key
     * @default 'ECDSA'
     * If you are using a custom storage provider that does not support CryptoKey storage,
     * you should use 'Ed25519' as the key type, as it can serialize to a string
     */
    keyType?: BaseKeyType;
    targets?: string[];
    /**
     * Expiration of the delegation in nanoseconds
     */
    maxTimeToLive?: bigint;
}
export declare class DelegationSignerClient extends SignerClient {
    private identity;
    private baseIdentity;
    private targets?;
    private maxTimeToLive;
    private expirationManager?;
    constructor(options: SignerClientOptions, identity: Identity | PartialIdentity, baseIdentity: SignIdentity | PartialIdentity, targets?: string[] | undefined, maxTimeToLive?: bigint);
    static create(options: DelegationSignerClientOptions): Promise<DelegationSignerClient>;
    private static createIdentity;
    login(): Promise<void>;
    private initExpirationManager;
    logout(options?: {
        returnTo?: string;
    }): Promise<void>;
    getIdentity(): Identity | PartialIdentity;
    getDelegationType(): Promise<DelegationType>;
    getDelegation(): Promise<import("@dfinity/identity").SignedDelegation | undefined>;
}
export {};
