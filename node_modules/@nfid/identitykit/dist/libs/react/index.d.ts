import * as react_jsx_runtime from 'react/jsx-runtime';
import React$1, { PropsWithChildren, HTMLProps, ComponentType } from 'react';
import { Delegation, PartialIdentity } from '@dfinity/identity';
import * as _dfinity_agent from '@dfinity/agent';
import { Agent as Agent$1, HttpAgent, Identity, SignIdentity } from '@dfinity/agent';
import * as _slide_computer_signer from '@slide-computer/signer';
import { Signer } from '@slide-computer/signer';
import { AuthClientStorage } from '@dfinity/auth-client';
import { MenuButtonProps, MenuItemsProps, MenuProps as MenuProps$1 } from '@headlessui/react';
import * as _dfinity_principal from '@dfinity/principal';
import { Principal } from '@dfinity/principal';
import * as _dfinity_ledger_icp from '@dfinity/ledger-icp';
import { SubAccount } from '@dfinity/ledger-icp';
import { SignerAgent } from '@slide-computer/signer-agent';

declare enum IdentityKitTheme {
    LIGHT = "light",
    DARK = "dark",
    SYSTEM = "system"
}
declare const DEFAULT_SIZES: {
    width: number;
    height: number;
};

type AgentOptions = {
    delegation?: Delegation;
    signerAgent: SignerAgent<Signer>;
    agent: HttpAgent;
    identity?: Identity | PartialIdentity;
};
declare class Agent implements Agent$1 {
    private signerAgentStrategy;
    private agentStrategy;
    private delegation?;
    private constructor();
    static create({ delegation, signerAgent, agent }: AgentOptions): Promise<Agent>;
    call(...params: Parameters<Agent$1["call"]>): ReturnType<Agent$1["call"]>;
    query(...params: Parameters<Agent$1["query"]>): ReturnType<Agent$1["query"]>;
    get rootKey(): ArrayBuffer | null;
    fetchRootKey(): ReturnType<Agent$1["fetchRootKey"]>;
    getPrincipal(): ReturnType<Agent$1["getPrincipal"]>;
    status(): ReturnType<Agent$1["status"]>;
    readState(...params: Parameters<Agent$1["readState"]>): ReturnType<Agent$1["readState"]>;
    createReadStateRequest?(): Promise<any>;
}

type IdleManagerOptions = {
    /**
     * capture scroll events
     * @default false
     */
    captureScroll?: boolean;
    /**
     * scroll debounce time in ms
     * @default 100
     */
    scrollDebounce?: number;
    /**
     * Callback after the user has gone idle
     */
    onIdle?: () => unknown;
    /**
     * timeout in ms
     */
    idleTimeout?: number;
};

interface IdleOptions extends IdleManagerOptions {
    /**
     * Disables idle functionality for {@link IdleManager}
     * @default false
     */
    disableIdle?: boolean;
    /**
     * Disables default idle behavior - call logout
     * @default false
     */
    disableDefaultIdleCallback?: boolean;
}
interface SignerClientOptions {
    signer: Signer;
    /**
     * Optional, used to generate random bytes
     * @default uses browser/node Crypto by default
     */
    crypto?: Pick<Crypto, "getRandomValues" | "randomUUID">;
    /**
     * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default
     */
    storage?: AuthClientStorage;
    /**
     * Options to handle idle timeouts
     * @default after 30 minutes, invalidates the identity
     */
    idleOptions?: IdleOptions;
    derivationOrigin?: string;
    onLogout?: () => Promise<unknown>;
}

declare const ED25519_KEY_LABEL = "Ed25519";
type BaseKeyType = "ECDSA" | typeof ED25519_KEY_LABEL;
declare enum DelegationType {
    ACCOUNT = "ACCOUNT",
    RELYING_PARTY = "RELYING_PARTY"
}
interface DelegationSignerClientOptions extends SignerClientOptions {
    /**
     * An identity to use as the base
     */
    identity?: SignIdentity | PartialIdentity;
    /**
     * type to use for the base key
     * @default 'ECDSA'
     * If you are using a custom storage provider that does not support CryptoKey storage,
     * you should use 'Ed25519' as the key type, as it can serialize to a string
     */
    keyType?: BaseKeyType;
    targets?: string[];
    /**
     * Expiration of the delegation in nanoseconds
     */
    maxTimeToLive?: bigint;
}

interface AccountsSignerClientOptions extends SignerClientOptions {
}

type ObjectValuesType<T> = T[keyof T];
declare const IdentityKitAuthType: {
    readonly DELEGATION: "DELEGATION";
    readonly ACCOUNTS: "ACCOUNTS";
};
type IdentityKitAuthType = ObjectValuesType<typeof IdentityKitAuthType>;

type SignerConfig = {
    id: string;
    providerUrl: string;
    label: string;
    transportType: TransportType;
    icon?: string;
    description?: string;
};
declare enum TransportType {
    NEW_TAB = 0,
    EXTENSION = 1,
    INTERNET_IDENTITY = 2,
    STOIC = 3,
    PLUG = 4
}

interface ProviderProps<T extends IdentityKitAuthType = typeof IdentityKitAuthType.ACCOUNTS> extends PropsWithChildren {
    authType?: T;
    signers?: SignerConfig[];
    featuredSigner?: SignerConfig | false;
    discoverExtensionSigners?: boolean;
    theme?: IdentityKitTheme;
    signerClientOptions?: T extends typeof IdentityKitAuthType.DELEGATION ? Omit<DelegationSignerClientOptions, "signer" | "crypto" | "agent"> : Omit<AccountsSignerClientOptions, "signer" | "crypto" | "agent">;
    onConnectFailure?: (e: Error) => unknown;
    onConnectSuccess?: () => unknown;
    onDisconnect?: () => unknown;
    realConnectDisabled?: boolean;
    crypto?: Pick<Crypto, "getRandomValues" | "randomUUID">;
    window?: Window;
    allowInternetIdentityPinAuthentication?: boolean;
}
declare const Provider: <T extends IdentityKitAuthType>({ children, signerClientOptions, crypto, window, authType, realConnectDisabled, allowInternetIdentityPinAuthentication, discoverExtensionSigners, ...props }: ProviderProps<T>) => react_jsx_runtime.JSX.Element;

type ConnectButtonProps = HTMLProps<HTMLButtonElement> & {
    loading?: boolean;
};
declare function ConnectButton({ onClick, className, disabled, loading, children, }: ConnectButtonProps): react_jsx_runtime.JSX.Element;

type ConnectedButtonProps = MenuButtonProps & {
    connectedAccount: string;
    icpBalance?: number;
};
declare function ConnectedButton({ connectedAccount, icpBalance, className, children, ...props }: ConnectedButtonProps): react_jsx_runtime.JSX.Element;

type ItemProps = React$1.HTMLProps<HTMLDivElement>;
declare function Item({ className, children, ...props }: React$1.HTMLProps<HTMLDivElement>): react_jsx_runtime.JSX.Element;

type ItemTextProps = React.HTMLProps<HTMLSpanElement>;

type ItemsProps = MenuItemsProps & {
    innerClassName?: string;
};
declare function Items({ className, innerClassName, children, ...props }: ItemsProps): react_jsx_runtime.JSX.Element;

type AddressItemProps = {
    value: string;
} & ItemProps;
declare function AddressItem({ value, onClick, ...props }: AddressItemProps): react_jsx_runtime.JSX.Element;

type DisconnectItemProps = ItemProps;
declare function DisconnectItem(props: DisconnectItemProps): react_jsx_runtime.JSX.Element;

type MenuProps = MenuProps$1 & {
    className?: string;
};
declare function Menu({ className, children, ...props }: MenuProps): react_jsx_runtime.JSX.Element;

type ButtonProps = MenuButtonProps;
declare function Button({ className, ...props }: MenuButtonProps): react_jsx_runtime.JSX.Element;

declare function ConnectWallet({ connectButtonComponent, connectedButtonComponent, dropdownMenuComponent, }: {
    connectButtonComponent?: ComponentType<ConnectButtonProps>;
    connectedButtonComponent?: ComponentType<ConnectedButtonProps>;
    dropdownMenuComponent?: ComponentType<MenuProps & {
        disconnect: () => unknown;
        icpBalance?: number;
        connectedAccount: string;
    }>;
}): react_jsx_runtime.JSX.Element;

declare function formatIcp(value: number): string;

declare function useIdentity(): _dfinity_agent.Identity | undefined;

declare function useAccounts(): {
    principal: Principal;
    subAccount?: SubAccount;
}[] | undefined;

declare function useDelegationType(): DelegationType | undefined;

declare function useAgent(agentOptions?: Omit<Parameters<typeof HttpAgent.create>[0], "identity">): Agent | undefined;

declare function useBalance(): {
    balance: number | undefined;
    fetchBalance: (() => Promise<void>) | undefined;
};

declare function useSigner(): _slide_computer_signer.Signer<_slide_computer_signer.Transport> | undefined;

declare function useIsInitializing(): boolean;

/**
 * @deprecated This function is deprecated. Please use separate hooks instead (useUser, useBalance etc).
 */
declare function useIdentityKit(): {
    signer?: Signer;
    user?: {
        principal: Principal;
        subaccount?: SubAccount;
    };
    icpBalance?: number;
    authType: IdentityKitAuthType;
    delegationType?: DelegationType;
    accounts?: {
        principal: Principal;
        subAccount?: SubAccount;
    }[];
    identity?: Identity | PartialIdentity;
    isInitializing: boolean;
    isUserConnecting: boolean;
    connect: (signerIdOrUrl?: string) => void;
    disconnect: () => Promise<void>;
    fetchIcpBalance?: () => Promise<void>;
};

declare function useAuth(): {
    user: {
        principal: _dfinity_principal.Principal;
        subAccount?: _dfinity_ledger_icp.SubAccount;
    } | undefined;
    isConnecting: boolean;
    connect: (signerIdOrUrl?: string) => Promise<void>;
    disconnect: () => Promise<void>;
};

export { ConnectWallet, ConnectButton as ConnectWalletButton, type ConnectButtonProps as ConnectWalletButtonProps, Menu as ConnectWalletDropdownMenu, AddressItem as ConnectWalletDropdownMenuAddressItem, type AddressItemProps as ConnectWalletDropdownMenuAddressItemProps, Button as ConnectWalletDropdownMenuButton, type ButtonProps as ConnectWalletDropdownMenuButtonProps, DisconnectItem as ConnectWalletDropdownMenuDisconnectItem, type DisconnectItemProps as ConnectWalletDropdownMenuDisconnectItemProps, Item as ConnectWalletDropdownMenuItem, type ItemProps as ConnectWalletDropdownMenuItemProps, type ItemTextProps as ConnectWalletDropdownMenuItemTextProps, Items as ConnectWalletDropdownMenuItems, type ItemsProps as ConnectWalletDropdownMenuItemsProps, type MenuProps as ConnectWalletDropdownMenuProps, ConnectedButton as ConnectedWalletButton, type ConnectButtonProps as ConnectedWalletButtonProps, DEFAULT_SIZES, Provider as IdentityKitProvider, IdentityKitTheme, formatIcp, useAccounts, useAgent, useAuth, useBalance, useDelegationType, useIdentity, useIdentityKit, useIsInitializing, useSigner };
