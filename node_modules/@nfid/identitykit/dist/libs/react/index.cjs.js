'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var useContextSelector = require('use-context-selector');
var signerAgent = require('@slide-computer/signer-agent');
var principal = require('@dfinity/principal');
var agent = require('@dfinity/agent');
var identity = require('@dfinity/identity');
var signerStorage = require('@slide-computer/signer-storage');
var ledgerIcp = require('@dfinity/ledger-icp');
var signer = require('@slide-computer/signer');
var signerWeb = require('@slide-computer/signer-web');
var signerExtension = require('@slide-computer/signer-extension');
var signerTransportAuthClient = require('@slide-computer/signer-transport-auth-client');
var signerTransportStoic = require('@slide-computer/signer-transport-stoic');
var signerTransportPlug = require('@slide-computer/signer-transport-plug');
var useAsyncMemo = require('use-async-memo');
var clsx = require('clsx');
var react$1 = require('@headlessui/react');
var colors = require('tailwindcss/colors');
var RadixTooltip = require('@radix-ui/react-tooltip');
var Dialog = require('@radix-ui/react-dialog');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var RadixTooltip__namespace = /*#__PURE__*/_interopNamespaceDefault(RadixTooltip);
var Dialog__namespace = /*#__PURE__*/_interopNamespaceDefault(Dialog);

exports.IdentityKitTheme = void 0;
(function (IdentityKitTheme) {
    IdentityKitTheme["LIGHT"] = "light";
    IdentityKitTheme["DARK"] = "dark";
    IdentityKitTheme["SYSTEM"] = "system";
})(exports.IdentityKitTheme || (exports.IdentityKitTheme = {}));
const DEFAULT_SIZES = {
    width: 450,
    height: 640,
};

const ThemeContext = react.createContext(exports.IdentityKitTheme.SYSTEM);

const Context = useContextSelector.createContext(null);

class Agent {
    signerAgentStrategy;
    agentStrategy;
    delegation;
    constructor(signerAgentStrategy, agentStrategy, delegation) {
        this.signerAgentStrategy = signerAgentStrategy;
        this.agentStrategy = agentStrategy;
        this.delegation = delegation;
    }
    static async create({ delegation, signerAgent, agent }) {
        return new Agent(signerAgent, agent, delegation);
    }
    async call(...params) {
        const delegationTargets = this.delegation?.targets;
        const strategy = this.delegation &&
            (!delegationTargets?.length ||
                delegationTargets?.find((t) => t.compareTo(principal.Principal.from(params[0])) === "eq"))
            ? this.agentStrategy
            : this.signerAgentStrategy;
        return strategy.call(...params);
    }
    async query(...params) {
        const delegationTargets = this.delegation?.targets;
        const strategy = this.delegation &&
            (!delegationTargets?.length ||
                delegationTargets?.find((t) => t.compareTo(principal.Principal.from(params[0])) === "eq"))
            ? this.agentStrategy
            : this.signerAgentStrategy;
        return strategy.query(...params);
    }
    get rootKey() {
        return this.agentStrategy.rootKey;
    }
    async fetchRootKey() {
        return this.agentStrategy.fetchRootKey();
    }
    async getPrincipal() {
        return this.agentStrategy.getPrincipal();
    }
    async status() {
        return this.agentStrategy.status();
    }
    async readState(...params) {
        const delegationTargets = this.delegation?.targets;
        const strategy = this.delegation &&
            (!delegationTargets?.length ||
                delegationTargets?.find((t) => t.compareTo(principal.Principal.from(params[0])) === "eq"))
            ? this.agentStrategy
            : this.signerAgentStrategy;
        return strategy.readState(...params);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async createReadStateRequest() {
        return {
            body: {
                content: {
                    ingress_expiry: undefined,
                },
            },
        };
    }
}

const DEFAULT_MAX_TIME_TO_LIVE = BigInt(1.8e12); // 30 min
const DEFAULT_IDLE_TIMEOUT = 14_400_000; // 4 hours

const TIMEOUT_MAX_DELAY = 2147483647;
/**
 * Detects if the `timeout` ms is over, and calls `onTimeout` and registered callbacks.
 * To override these defaults, you can pass an `onTimeout` callback, or configure a custom `timeout` in milliseconds
 */
class TimeoutManager {
    callbacks = [];
    timeout;
    timeoutID = undefined;
    /**
     * @param options {@link IdleManagerOptions}
     */
    constructor(options) {
        const { onTimeout, timeout } = options || {};
        this.callbacks = onTimeout ? [onTimeout] : [];
        this.timeout = timeout > TIMEOUT_MAX_DELAY ? TIMEOUT_MAX_DELAY : timeout;
        const _resetTimer = this._resetTimer.bind(this);
        window.addEventListener("load", _resetTimer, true);
        _resetTimer();
    }
    /**
     * @param {TimeoutCB} callback function to be called on timeout
     */
    registerCallback(callback) {
        this.callbacks.push(callback);
    }
    /**
     * Cleans up the timeout manager and its listeners
     */
    exit() {
        clearTimeout(this.timeoutID);
        window.removeEventListener("load", this._resetTimer, true);
    }
    /**
     * Resets the timeouts during cleanup
     */
    _resetTimer() {
        const exit = this.exit.bind(this);
        window.clearTimeout(this.timeoutID);
        this.timeoutID = window.setTimeout(() => {
            exit();
            this.callbacks.forEach((cb) => cb());
        }, this.timeout);
    }
}

const events = ["mousedown", "mousemove", "keydown", "touchstart", "wheel"];
/**
 * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.
 * By default, the IdleManager will log a user out after 10 minutes of inactivity.
 * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds
 */
class IdleManager extends TimeoutManager {
    constructor(options = {}) {
        super({ timeout: options.idleTimeout || DEFAULT_IDLE_TIMEOUT, onTimeout: options.onIdle });
        const _resetTimer = this._resetTimer.bind(this);
        events.forEach(function (name) {
            document.addEventListener(name, _resetTimer, true);
        });
        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const context = this;
                const later = function () {
                    timeout = undefined;
                    func.apply(context, args);
                };
                clearTimeout(timeout);
                timeout = window.setTimeout(later, wait);
            };
        };
        if (options?.captureScroll) {
            // debounce scroll events
            const scroll = debounce(_resetTimer, options?.scrollDebounce ?? 100);
            window.addEventListener("scroll", scroll, true);
        }
    }
}

const STORAGE_KEY = "client";
const STORAGE_CONNECTED_OWNER_KEY = "connected-owner";
const STORAGE_CONNECTED_SUBACCOUNT_KEY = "connected-subaccount";
class SignerClient {
    options;
    idleManager;
    storage = new signerStorage.IdbStorage();
    connectedUser;
    constructor(options) {
        this.options = options;
        if (!options?.idleOptions?.disableIdle) {
            this.idleManager = new IdleManager(options.idleOptions);
            this.registerDefaultIdleCallback();
        }
        if (options.storage)
            this.storage = options.storage;
    }
    registerDefaultIdleCallback() {
        /**
         * Default behavior is to clear stored identity and reload the page.
         * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config
         */
        if (!this.options?.idleOptions?.disableDefaultIdleCallback) {
            this.idleManager?.registerCallback(async () => {
                await this.logout();
            });
        }
    }
    async logout(options) {
        await this.setConnectedUserToStorage(undefined);
        this.idleManager?.exit();
        this.idleManager = undefined;
        await this.options.onLogout?.();
        if (options?.returnTo) {
            try {
                window.history.pushState({}, "", options.returnTo);
            }
            catch (e) {
                window.location.href = options.returnTo;
            }
        }
    }
    async setConnectedUser(user) {
        if (!user)
            this.connectedUser = undefined;
        else {
            let subAccount;
            if (user.subAccount) {
                const subAccountOrError = ledgerIcp.SubAccount.fromBytes(new Uint8Array(user.subAccount));
                if (typeof subAccountOrError === typeof Error) {
                    throw subAccount;
                }
                subAccount = subAccountOrError;
            }
            this.connectedUser = {
                principal: principal.Principal.from(user.owner),
                subAccount,
            };
        }
    }
    async setConnectedUserToStorage(user) {
        if (!user) {
            await this.storage.remove(STORAGE_CONNECTED_OWNER_KEY);
            await this.storage.remove(STORAGE_CONNECTED_SUBACCOUNT_KEY);
            localStorage.removeItem("connected");
            this.setConnectedUser(undefined);
            return;
        }
        await this.storage.set(STORAGE_CONNECTED_OWNER_KEY, user.owner);
        localStorage.setItem("connected", "1");
        if (user.subAccount)
            await this.storage.set(STORAGE_CONNECTED_SUBACCOUNT_KEY, new TextDecoder().decode(user.subAccount));
        this.setConnectedUser({
            owner: user.owner,
            subAccount: user.subAccount,
        });
    }
    // sync method to check if it's needed to check authorization reading from async storage
    static shouldCheckIsUserConnected() {
        return !!localStorage.getItem("connected");
    }
    async getConnectedUserFromStorage() {
        const owner = await this.storage.get(STORAGE_CONNECTED_OWNER_KEY);
        if (!owner)
            return;
        const subAccount = await this.storage.get(STORAGE_CONNECTED_SUBACCOUNT_KEY);
        return {
            owner: owner.toString(),
            subAccount: subAccount
                ? new TextEncoder().encode(subAccount.toString()).buffer
                : undefined,
        };
    }
    get crypto() {
        return this.options.crypto ?? globalThis.crypto;
    }
}

const ED25519_KEY_LABEL = "Ed25519";
var DelegationType;
(function (DelegationType) {
    DelegationType["ACCOUNT"] = "ACCOUNT";
    DelegationType["RELYING_PARTY"] = "RELYING_PARTY";
})(DelegationType || (DelegationType = {}));
const NANOS_IN_MILLIS = BigInt(1000000);
class DelegationSignerClient extends SignerClient {
    identity;
    baseIdentity;
    targets;
    maxTimeToLive;
    expirationManager;
    constructor(options, identity, baseIdentity, targets, maxTimeToLive = BigInt(DEFAULT_MAX_TIME_TO_LIVE)) {
        // TODO for delegation use delegation expiration as idle timeout
        super(options);
        this.identity = identity;
        this.baseIdentity = baseIdentity;
        this.targets = targets;
        this.maxTimeToLive = maxTimeToLive;
    }
    static async create(options) {
        const storage = options.storage ?? new signerStorage.IdbStorage();
        let baseIdentity = options.identity;
        let identity$1 = new agent.AnonymousIdentity();
        if (this.shouldCheckIsUserConnected() && !baseIdentity) {
            baseIdentity = await signerStorage.getIdentity(STORAGE_KEY, storage);
        }
        if (!baseIdentity) {
            const createdBaseIdentity = await (!options?.keyType || options?.keyType === ED25519_KEY_LABEL
                ? identity.Ed25519KeyIdentity.generate(crypto.getRandomValues(new Uint8Array(32)))
                : identity.ECDSAKeyIdentity.generate());
            baseIdentity = createdBaseIdentity;
        }
        if (this.shouldCheckIsUserConnected()) {
            const delegationChain = await signerStorage.getDelegationChain(STORAGE_KEY, storage);
            const delegationValid = baseIdentity && delegationChain && identity.isDelegationValid(delegationChain);
            identity$1 = delegationValid
                ? DelegationSignerClient.createIdentity(baseIdentity, delegationChain)
                : new agent.AnonymousIdentity();
            const signerClient = new DelegationSignerClient(options, identity$1, baseIdentity, options.targets, options.maxTimeToLive);
            if (delegationValid) {
                signerClient.initExpirationManager(delegationChain);
            }
            const storageConnectedUser = await signerClient.getConnectedUserFromStorage();
            await signerClient.setConnectedUser(storageConnectedUser);
            return signerClient;
        }
        const signerClient = new DelegationSignerClient(options, identity$1, baseIdentity, options.targets, options.maxTimeToLive);
        return signerClient;
    }
    static createIdentity(baseIdentity, delegationChain) {
        if (baseIdentity instanceof identity.PartialIdentity) {
            return identity.PartialDelegationIdentity.fromDelegation(baseIdentity, delegationChain);
        }
        return identity.DelegationIdentity.fromDelegation(baseIdentity, delegationChain);
    }
    async login() {
        const params = this.options.derivationOrigin
            ? {
                icrc95DerivationOrigin: this.options.derivationOrigin,
            }
            : {};
        const delegationChainResponse = await this.options.signer.sendRequest({
            id: this.crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc34_delegation",
            params: {
                ...params,
                publicKey: signer.toBase64(this.baseIdentity.getPublicKey().toDer()),
                targets: this.targets,
                maxTimeToLive: this.maxTimeToLive === undefined ? undefined : String(this.maxTimeToLive),
            },
        });
        if ("error" in delegationChainResponse) {
            throw Error(delegationChainResponse.error.message);
        }
        const delegationChain = identity.DelegationChain.fromDelegations(delegationChainResponse.result.signerDelegation.map((delegation) => {
            return {
                delegation: new identity.Delegation(signer.fromBase64(delegation.delegation.pubkey), BigInt(delegation.delegation.expiration), delegation.delegation.targets?.map((principal$1) => principal.Principal.fromText(principal$1))),
                signature: signer.fromBase64(delegation.signature),
            };
        }), signer.fromBase64(delegationChainResponse.result.publicKey));
        if (this.baseIdentity instanceof identity.Ed25519KeyIdentity ||
            this.baseIdentity instanceof identity.ECDSAKeyIdentity) {
            await signerStorage.setIdentity(STORAGE_KEY, this.baseIdentity, this.storage);
        }
        await signerStorage.setDelegationChain(STORAGE_KEY, delegationChain, this.storage);
        this.identity = DelegationSignerClient.createIdentity(this.baseIdentity, delegationChain);
        await this.setConnectedUserToStorage({ owner: this.identity.getPrincipal().toString() });
        if (!this.options?.idleOptions?.disableIdle && !this.idleManager) {
            this.idleManager = new IdleManager(this.options.idleOptions);
            this.registerDefaultIdleCallback();
        }
        return this.initExpirationManager(delegationChain);
    }
    initExpirationManager(delegationChain) {
        if (!this.expirationManager) {
            const delegationExpirationInMillis = Number(delegationChain.delegations.reduce((acc, value) => {
                const bigIntValue = BigInt(value.delegation.expiration) / NANOS_IN_MILLIS;
                return bigIntValue > acc ? bigIntValue : acc;
            }, BigInt(delegationChain.delegations[0].delegation.expiration) / NANOS_IN_MILLIS)) - Date.now();
            this.expirationManager = new TimeoutManager({ timeout: delegationExpirationInMillis });
            this.expirationManager?.registerCallback(async () => {
                await this.logout();
            });
        }
    }
    async logout(options) {
        await Promise.all([
            signerStorage.removeIdentity(STORAGE_KEY, this.storage),
            signerStorage.removeDelegationChain(STORAGE_KEY, this.storage),
        ]);
        this.identity = new agent.AnonymousIdentity();
        return super.logout(options);
    }
    getIdentity() {
        return this.identity;
    }
    async getDelegationType() {
        if (!this.connectedUser)
            throw new Error("Not authorized");
        const delegationChain = await signerStorage.getDelegationChain(STORAGE_KEY, this.storage);
        if (!delegationChain)
            throw new Error("Not authorized");
        return delegationChain.delegations[0].delegation.targets?.length
            ? DelegationType.ACCOUNT
            : DelegationType.RELYING_PARTY;
    }
    async getDelegation() {
        const chain = await signerStorage.getDelegationChain(STORAGE_KEY, this.storage);
        return chain?.delegations[0];
    }
}

class AccountsSignerClient extends SignerClient {
    static async create(options) {
        const signerClient = new AccountsSignerClient(options);
        if (SignerClient.shouldCheckIsUserConnected()) {
            const storageConnectedUser = await signerClient.getConnectedUserFromStorage();
            await signerClient.setConnectedUser(storageConnectedUser);
        }
        return signerClient;
    }
    async login() {
        // get and transform accounts from signer
        const params = this.options.derivationOrigin
            ? {
                params: {
                    icrc95DerivationOrigin: this.options.derivationOrigin,
                },
            }
            : {};
        const accountsResponse = await this.options.signer.sendRequest({
            method: "icrc27_accounts",
            id: this.crypto.randomUUID(),
            jsonrpc: "2.0",
            ...params,
        });
        if ("error" in accountsResponse) {
            throw Error(accountsResponse.error.message);
        }
        const accounts = accountsResponse.result.accounts.map(({ owner, subaccount }) => {
            return {
                owner: principal.Principal.fromText(owner),
                subaccount: subaccount === undefined ? undefined : signer.fromBase64(subaccount),
            };
        });
        await this.setAccounts(accounts);
        const account = accounts[0];
        if (!account.subaccount) {
            if (!this.options?.idleOptions?.disableIdle && !this.idleManager) {
                this.idleManager = new IdleManager(this.options.idleOptions);
                this.registerDefaultIdleCallback();
            }
            await this.setConnectedUserToStorage({ owner: account.owner.toString() });
            return;
        }
        await this.setConnectedUserToStorage({
            owner: account.owner.toString(),
            subAccount: account.subaccount,
        });
        if (!this.options?.idleOptions?.disableIdle && !this.idleManager) {
            this.idleManager = new IdleManager(this.options.idleOptions);
            this.registerDefaultIdleCallback();
        }
    }
    async logout(options) {
        await this.storage.remove(`accounts-${STORAGE_KEY}`);
        return super.logout(options);
    }
    async setAccounts(accounts) {
        return this.storage.set(`accounts-${STORAGE_KEY}`, JSON.stringify(accounts.map((acc) => ({
            owner: acc.owner.toString(),
            subaccount: acc.subaccount && new TextDecoder().decode(acc.subaccount),
        }))));
    }
    async getAccounts() {
        const storageData = await this.storage.get(`accounts-${STORAGE_KEY}`);
        if (!storageData || typeof storageData !== "string")
            return;
        return JSON.parse(storageData).map(({ owner, subaccount }) => {
            let subAccount;
            if (subaccount) {
                const subAccountOrError = ledgerIcp.SubAccount.fromBytes(new Uint8Array(new TextEncoder().encode(subaccount)));
                if (typeof subAccountOrError === typeof Error) {
                    throw subAccount;
                }
                subAccount = subAccountOrError;
            }
            return {
                principal: principal.Principal.from(owner),
                subAccount,
            };
        });
    }
}

const IdentityKitAuthType = {
    DELEGATION: "DELEGATION",
    ACCOUNTS: "ACCOUNTS",
};
class IdentityKit {
    signerClient;
    constructor(signerClient) {
        this.signerClient = signerClient;
    }
    async getIcpBalance() {
        const connectedUser = await this.signerClient.connectedUser;
        if (!connectedUser)
            throw new Error("Not authenticated");
        const balance = (await ledgerIcp.LedgerCanister.create().accountBalance({
            accountIdentifier: ledgerIcp.AccountIdentifier.fromPrincipal({
                principal: connectedUser.principal,
                subAccount: connectedUser.subAccount,
            }),
            certified: false,
        })).toString();
        return Number(balance) / 10 ** 8;
    }
    static async create({ signerClientOptions, authType }) {
        if (authType === IdentityKitAuthType.DELEGATION) {
            const signerClient = await DelegationSignerClient.create(signerClientOptions);
            return new this(signerClient);
        }
        else {
            const signerClient = await AccountsSignerClient.create(signerClientOptions);
            return new this(signerClient);
        }
    }
}

var TransportType;
(function (TransportType) {
    TransportType[TransportType["NEW_TAB"] = 0] = "NEW_TAB";
    TransportType[TransportType["EXTENSION"] = 1] = "EXTENSION";
    TransportType[TransportType["INTERNET_IDENTITY"] = 2] = "INTERNET_IDENTITY";
    TransportType[TransportType["STOIC"] = 3] = "STOIC";
    TransportType[TransportType["PLUG"] = 4] = "PLUG";
})(TransportType || (TransportType = {}));

const NFIDW = {
    id: "NFIDW",
    description: "Quickly sign in or create an anonymous, self-sovereign wallet with your email address or passkey.",
    providerUrl: "https://nfid.one/rpc",
    transportType: TransportType.NEW_TAB,
    label: "NFID Wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZD0iTTExLjc5NCAyLjQzM0ExLjE2MiAxLjE2MiAwIDAgMCAxMS41NDguMTJMOS4xNzQuMzc0Yy0xLjIxNi4xMy0yLjE5MS4yMzQtMi45ODMuMzc4LS44MTYuMTQ4LTEuNTE2LjM1LTIuMTY1LjcxNGE2LjY3NSA2LjY3NSAwIDAgMC0yLjUzIDIuNTA2Yy0uMzcuNjQ2LS41NzggMS4zNDMtLjczMiAyLjE1N0MuNjE0IDYuOTE5LjUgNy44OTMuMzYgOS4xMDZsLS4wMDYuMDUyLS4yMzMgMi4zMThhMS4xNjIgMS4xNjIgMCAxIDAgMi4zMTMuMjMybC4yMzEtMi4zYy4xNDYtMS4yNjQuMjQ5LTIuMTUuMzgxLTIuODQ1LjEzLS42ODIuMjc1LTEuMS40NjctMS40MzZhNC4zNSA0LjM1IDAgMCAxIDEuNjQ4LTEuNjMzYy4zMzgtLjE5Ljc2LS4zMzEgMS40NDMtLjQ1NS42OTktLjEyNyAxLjU5LS4yMjMgMi44Ni0uMzU4bDIuMzMtLjI0OFptMjIuNjEzLTEuMjhhMS4xNjIgMS4xNjIgMCAwIDAgMS4wMzMgMS4yOGwyLjMzLjI0OGMxLjI3LjEzNSAyLjE2LjIzMSAyLjg1OS4zNTguNjg0LjEyNCAxLjEwNS4yNjUgMS40NDMuNDU1YTQuMzUgNC4zNSAwIDAgMSAxLjY0OCAxLjYzM2MuMTkzLjMzNS4zMzcuNzU0LjQ2NyAxLjQzNi4xMzIuNjk1LjIzNSAxLjU4MS4zOCAyLjg0NGwuMjMyIDIuMzAyYTEuMTYyIDEuMTYyIDAgMSAwIDIuMzEzLS4yMzNsLS4yMzMtMi4zMTgtLjAwNi0uMDUyYy0uMTQtMS4yMTQtLjI1Mi0yLjE4Ny0uNDAyLTIuOTc3LS4xNTUtLjgxNC0uMzY0LTEuNTExLS43MzQtMi4xNTdhNi42NzUgNi42NzUgMCAwIDAtMi41MjktMi41MDZjLS42NS0uMzY0LTEuMzQ5LS41NjYtMi4xNjUtLjcxNC0uNzkyLS4xNDQtMS43NjctLjI0OC0yLjk4My0uMzc4TDM1LjY4Ni4xMjFhMS4xNjIgMS4xNjIgMCAwIDAtMS4yNzkgMS4wMzNabTAgNDQuOTIzYTEuMTYyIDEuMTYyIDAgMCAxIDEuMDMzLTEuMjhsMi4zMy0uMjQ4YzEuMjctLjEzNSAyLjE2LS4yMyAyLjg1OS0uMzU3LjY4NC0uMTI0IDEuMTA1LS4yNjYgMS40NDMtLjQ1NWE0LjM1IDQuMzUgMCAwIDAgMS42NDgtMS42MzNjLjE5My0uMzM2LjMzNy0uNzU1LjQ2Ny0xLjQzNy4xMzItLjY5NS4yMzUtMS41ODEuMzgtMi44NDRsLjIzMi0yLjMwMWExLjE2MiAxLjE2MiAwIDEgMSAyLjMxMy4yMzNsLS4yMzMgMi4zMTctLjAwNi4wNTNjLS4xNCAxLjIxMy0uMjUyIDIuMTg2LS40MDIgMi45NzYtLjE1NS44MTQtLjM2NCAxLjUxMi0uNzM0IDIuMTU4YTYuNjc1IDYuNjc1IDAgMCAxLTIuNTI5IDIuNTA2Yy0uNjUuMzY0LTEuMzQ5LjU2Ni0yLjE2NS43MTQtLjc5Mi4xNDMtMS43NjcuMjQ3LTIuOTgzLjM3N2wtMi4zNzQuMjUzYTEuMTYyIDEuMTYyIDAgMCAxLTEuMjc5LTEuMDMyWm0tMjEuNTggMGExLjE2MiAxLjE2MiAwIDAgMC0xLjAzMy0xLjI4bC0yLjMzLS4yNDhjLTEuMjctLjEzNS0yLjE2LS4yMy0yLjg1OS0uMzU3LS42ODQtLjEyNC0xLjEwNS0uMjY2LTEuNDQzLS40NTVhNC4zNSA0LjM1IDAgMCAxLTEuNjQ4LTEuNjMzYy0uMTkyLS4zMzYtLjMzNy0uNzU1LS40NjctMS40MzctLjEzMi0uNjk1LS4yMzUtMS41ODEtLjM4LTIuODQ0bC0uMjMyLTIuMzAxYTEuMTYyIDEuMTYyIDAgMCAwLTIuMzEzLjIzM2wuMjMzIDIuMzE3LjAwNi4wNTNjLjE0IDEuMjEzLjI1MiAyLjE4Ni40MDMgMi45NzYuMTU0LjgxNC4zNjMgMS41MTIuNzMzIDIuMTU4YTYuNjc0IDYuNjc0IDAgMCAwIDIuNTI5IDIuNTA2Yy42NS4zNjQgMS4zNDkuNTY2IDIuMTY1LjcxNC43OTIuMTQzIDEuNzY3LjI0NyAyLjk4My4zNzdsMi4zNzQuMjUzYTEuMTYyIDEuMTYyIDAgMCAwIDEuMjc5LTEuMDMyWm0tLjYzNi0zMS40MjJhMSAxIDAgMCAwLTEgMXYxNi4yNjRhMSAxIDAgMCAwIDEgMWgzLjE2NmExIDEgMCAwIDAgMS0xVjE1LjY1NGExIDEgMCAwIDAtMS0xaC0zLjE2NlptOC41NiAwYTEgMSAwIDAgMC0xIDF2MTYuMjY0YTEgMSAwIDAgMCAxIDFoNy42MzdjMiAwIDMuNzc0LS4zNzQgNS4zMjItMS4xMjIgMS41NDgtLjc0OCAyLjc0OS0xLjgwOSAzLjYwMS0zLjE4My44NTItMS4zNzQgMS4yNzktMi45ODMgMS4yNzktNC44MjcgMC0xLjg0NC0uNDI3LTMuNDUzLTEuMjc5LTQuODI3LS44NTItMS4zNzQtMi4wNTMtMi40MzUtMy42LTMuMTgzLTEuNTQ5LS43NDgtMy4zMjMtMS4xMjItNS4zMjMtMS4xMjJIMjAuNzVabTExLjE4NSAxMi44MTFjLS45NC44ODctMi4xOTIgMS4zMy0zLjc1NyAxLjMzaC0yLjk2MmEuMy4zIDAgMCAxLS4zLS4zdi05LjQxOWEuMy4zIDAgMCAxIC4zLS4zaDIuOTYyYzEuNTY1IDAgMi44MTguNDQ0IDMuNzU3IDEuMzMxLjk1Ny44ODcgMS40MzUgMi4xMTQgMS40MzUgMy42OCAwIDEuNTY1LS40NzggMi43OS0xLjQzNSAzLjY3OFoiIGZpbGw9InVybCgjYSkiIC8+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSIxMS40MTUiIHkxPSIxNS43NTYiIHgyPSIyNy41NDgiIHkyPSIzOS4yMDYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0NDNUNEQyIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIuMjQ1IiBzdG9wLWNvbG9yPSIjN0I2NkZGIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii41MjEiIHN0b3AtY29sb3I9IiMxRjhBRjAiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iLjc2IiBzdG9wLWNvbG9yPSIjMDBEMUZGIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzREVERDciIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KPC9zdmc+Cg==",
};
({
    id: "MockedSigner",
    providerUrl: "https://icrc-25-example-signer.nfid.one",
    transportType: TransportType.NEW_TAB,
    label: "Mocked Signer Wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZD0iTTExLjc5NCAyLjQzM0ExLjE2MiAxLjE2MiAwIDAgMCAxMS41NDguMTJMOS4xNzQuMzc0Yy0xLjIxNi4xMy0yLjE5MS4yMzQtMi45ODMuMzc4LS44MTYuMTQ4LTEuNTE2LjM1LTIuMTY1LjcxNGE2LjY3NSA2LjY3NSAwIDAgMC0yLjUzIDIuNTA2Yy0uMzcuNjQ2LS41NzggMS4zNDMtLjczMiAyLjE1N0MuNjE0IDYuOTE5LjUgNy44OTMuMzYgOS4xMDZsLS4wMDYuMDUyLS4yMzMgMi4zMThhMS4xNjIgMS4xNjIgMCAxIDAgMi4zMTMuMjMybC4yMzEtMi4zYy4xNDYtMS4yNjQuMjQ5LTIuMTUuMzgxLTIuODQ1LjEzLS42ODIuMjc1LTEuMS40NjctMS40MzZhNC4zNSA0LjM1IDAgMCAxIDEuNjQ4LTEuNjMzYy4zMzgtLjE5Ljc2LS4zMzEgMS40NDMtLjQ1NS42OTktLjEyNyAxLjU5LS4yMjMgMi44Ni0uMzU4bDIuMzMtLjI0OFptMjIuNjEzLTEuMjhhMS4xNjIgMS4xNjIgMCAwIDAgMS4wMzMgMS4yOGwyLjMzLjI0OGMxLjI3LjEzNSAyLjE2LjIzMSAyLjg1OS4zNTguNjg0LjEyNCAxLjEwNS4yNjUgMS40NDMuNDU1YTQuMzUgNC4zNSAwIDAgMSAxLjY0OCAxLjYzM2MuMTkzLjMzNS4zMzcuNzU0LjQ2NyAxLjQzNi4xMzIuNjk1LjIzNSAxLjU4MS4zOCAyLjg0NGwuMjMyIDIuMzAyYTEuMTYyIDEuMTYyIDAgMSAwIDIuMzEzLS4yMzNsLS4yMzMtMi4zMTgtLjAwNi0uMDUyYy0uMTQtMS4yMTQtLjI1Mi0yLjE4Ny0uNDAyLTIuOTc3LS4xNTUtLjgxNC0uMzY0LTEuNTExLS43MzQtMi4xNTdhNi42NzUgNi42NzUgMCAwIDAtMi41MjktMi41MDZjLS42NS0uMzY0LTEuMzQ5LS41NjYtMi4xNjUtLjcxNC0uNzkyLS4xNDQtMS43NjctLjI0OC0yLjk4My0uMzc4TDM1LjY4Ni4xMjFhMS4xNjIgMS4xNjIgMCAwIDAtMS4yNzkgMS4wMzNabTAgNDQuOTIzYTEuMTYyIDEuMTYyIDAgMCAxIDEuMDMzLTEuMjhsMi4zMy0uMjQ4YzEuMjctLjEzNSAyLjE2LS4yMyAyLjg1OS0uMzU3LjY4NC0uMTI0IDEuMTA1LS4yNjYgMS40NDMtLjQ1NWE0LjM1IDQuMzUgMCAwIDAgMS42NDgtMS42MzNjLjE5My0uMzM2LjMzNy0uNzU1LjQ2Ny0xLjQzNy4xMzItLjY5NS4yMzUtMS41ODEuMzgtMi44NDRsLjIzMi0yLjMwMWExLjE2MiAxLjE2MiAwIDEgMSAyLjMxMy4yMzNsLS4yMzMgMi4zMTctLjAwNi4wNTNjLS4xNCAxLjIxMy0uMjUyIDIuMTg2LS40MDIgMi45NzYtLjE1NS44MTQtLjM2NCAxLjUxMi0uNzM0IDIuMTU4YTYuNjc1IDYuNjc1IDAgMCAxLTIuNTI5IDIuNTA2Yy0uNjUuMzY0LTEuMzQ5LjU2Ni0yLjE2NS43MTQtLjc5Mi4xNDMtMS43NjcuMjQ3LTIuOTgzLjM3N2wtMi4zNzQuMjUzYTEuMTYyIDEuMTYyIDAgMCAxLTEuMjc5LTEuMDMyWm0tMjEuNTggMGExLjE2MiAxLjE2MiAwIDAgMC0xLjAzMy0xLjI4bC0yLjMzLS4yNDhjLTEuMjctLjEzNS0yLjE2LS4yMy0yLjg1OS0uMzU3LS42ODQtLjEyNC0xLjEwNS0uMjY2LTEuNDQzLS40NTVhNC4zNSA0LjM1IDAgMCAxLTEuNjQ4LTEuNjMzYy0uMTkyLS4zMzYtLjMzNy0uNzU1LS40NjctMS40MzctLjEzMi0uNjk1LS4yMzUtMS41ODEtLjM4LTIuODQ0bC0uMjMyLTIuMzAxYTEuMTYyIDEuMTYyIDAgMCAwLTIuMzEzLjIzM2wuMjMzIDIuMzE3LjAwNi4wNTNjLjE0IDEuMjEzLjI1MiAyLjE4Ni40MDMgMi45NzYuMTU0LjgxNC4zNjMgMS41MTIuNzMzIDIuMTU4YTYuNjc0IDYuNjc0IDAgMCAwIDIuNTI5IDIuNTA2Yy42NS4zNjQgMS4zNDkuNTY2IDIuMTY1LjcxNC43OTIuMTQzIDEuNzY3LjI0NyAyLjk4My4zNzdsMi4zNzQuMjUzYTEuMTYyIDEuMTYyIDAgMCAwIDEuMjc5LTEuMDMyWm0tLjYzNi0zMS40MjJhMSAxIDAgMCAwLTEgMXYxNi4yNjRhMSAxIDAgMCAwIDEgMWgzLjE2NmExIDEgMCAwIDAgMS0xVjE1LjY1NGExIDEgMCAwIDAtMS0xaC0zLjE2NlptOC41NiAwYTEgMSAwIDAgMC0xIDF2MTYuMjY0YTEgMSAwIDAgMCAxIDFoNy42MzdjMiAwIDMuNzc0LS4zNzQgNS4zMjItMS4xMjIgMS41NDgtLjc0OCAyLjc0OS0xLjgwOSAzLjYwMS0zLjE4My44NTItMS4zNzQgMS4yNzktMi45ODMgMS4yNzktNC44MjcgMC0xLjg0NC0uNDI3LTMuNDUzLTEuMjc5LTQuODI3LS44NTItMS4zNzQtMi4wNTMtMi40MzUtMy42LTMuMTgzLTEuNTQ5LS43NDgtMy4zMjMtMS4xMjItNS4zMjMtMS4xMjJIMjAuNzVabTExLjE4NSAxMi44MTFjLS45NC44ODctMi4xOTIgMS4zMy0zLjc1NyAxLjMzaC0yLjk2MmEuMy4zIDAgMCAxLS4zLS4zdi05LjQxOWEuMy4zIDAgMCAxIC4zLS4zaDIuOTYyYzEuNTY1IDAgMi44MTguNDQ0IDMuNzU3IDEuMzMxLjk1Ny44ODcgMS40MzUgMi4xMTQgMS40MzUgMy42OCAwIDEuNTY1LS40NzggMi43OS0xLjQzNSAzLjY3OFoiIGZpbGw9InVybCgjYSkiIC8+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSIxMS40MTUiIHkxPSIxNS43NTYiIHgyPSIyNy41NDgiIHkyPSIzOS4yMDYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0NDNUNEQyIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIuMjQ1IiBzdG9wLWNvbG9yPSIjN0I2NkZGIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii41MjEiIHN0b3AtY29sb3I9IiMxRjhBRjAiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iLjc2IiBzdG9wLWNvbG9yPSIjMDBEMUZGIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzREVERDciIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KPC9zdmc+Cg==",
});
const Plug = {
    id: "Plug",
    providerUrl: "",
    transportType: TransportType.PLUG,
    label: "Plug",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjcwMSIgaGVpZ2h0PSIzOTI1IiB2aWV3Qm94PSIwIDAgMjcwMSAzOTI1IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMCAxMTIzLjc4QzAgMTAzNi42NCA3MC42NDIgOTY2IDE1Ny43ODMgOTY2SDI1NDIuMjhDMjYyOS40MyA5NjYgMjcwMC4wNyAxMDM2LjY0IDI3MDAuMDcgMTEyMy43OFYxOTA5Ljc0QzI3MDAuMDcgMjY1NS4zNCAyMDk1LjY0IDMyNTkuNzggMTM1MC4wMyAzMjU5Ljc4QzYwNC40MzEgMzI1OS43OCAwIDI2NTUuMzQgMCAxOTA5Ljc0VjExMjMuNzhaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXIpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjU5My4xNyAyNDM3LjNDMjM4Ny43NyAyOTIwLjgzIDE5MDguNSAzMjU5Ljk0IDEzNTAuMDMgMzI1OS45NEM2MDQuNDMxIDMyNTkuOTQgMCAyNjU1LjUxIDAgMTkwOS45VjEzNDIuMTZDMjU2LjQxNiAxMjAwLjU4IDU1MS4yMjMgMTEyMCA4NjQuODUgMTEyMEMxNjkwLjE3IDExMjAgMjM4NS4xNyAxNjc3Ljk5IDI1OTMuMTcgMjQzNy4zWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyKSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIyNzAuMzggMjg5OC41MkMyMDI5LjI0IDMxMjMuMyAxNzA1LjcgMzI2MC44NCAxMzUwLjAzIDMyNjAuODRDNjA0LjQzMSAzMjYwLjg0IDAgMjY1Ni40MSAwIDE5MTAuOFYxNzY2LjQ4QzIyOC40OTUgMTYyMy41OSA0OTguNTY4IDE1NDEgNzg3LjkzMSAxNTQxQzE1NjUuNzkgMTU0MSAyMjA0LjI1IDIxMzcuODIgMjI3MC4zOCAyODk4LjUyWiIgZmlsbD0idXJsKCNwYWludDJfbGluZWFyKSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE4MDQuMyAzMTg4LjcxQzE3NzYuMjIgMjU2NS41NiAxMjY0IDIwNjkgNjM2LjIyMiAyMDY5QzQxOC4wMzIgMjA2OSAyMTMuNzk5IDIxMjguOTggMzkgMjIzMy40MkMxNDcuNjg4IDI2NzguNzMgNDc1LjM0NCAzMDM3Ljc2IDkwMC44OTQgMzE4OC45OFYzMjY0LjQ0QzkwMC44OTQgMzM3My42OSA5NTkuNTkgMzQ2OS4xOCAxMDQ3LjA2IDM1MjAuODhWMzcyNi4zN0MxMDQ3LjA2IDM4MzUuODYgMTEzNS40OSAzOTI0LjYxIDEyNDQuNTcgMzkyNC42MUgxNDU5Ljg2QzE1NjguOTUgMzkyNC42MSAxNjU3LjM4IDM4MzUuODYgMTY1Ny4zOCAzNzI2LjM3VjM1MjAuODhDMTc0NC44NSAzNDY5LjE4IDE4MDMuNTQgMzM3My42OSAxODAzLjU0IDMyNjQuNDRWMzE4OC45OEMxODAzLjggMzE4OC44OSAxODA0LjA1IDMxODguOCAxODA0LjMgMzE4OC43MVoiIGZpbGw9InVybCgjcGFpbnQzX2xpbmVhcikiLz4KPHBhdGggZD0iTTUwNCA2MEM1MDQgMjYuODYyOSA1MzAuODYzIDAgNTY0IDBIODM4Qzg3MS4xMzcgMCA4OTggMjYuODYyOSA4OTggNjBWOTY2SDUwNFY2MFoiIGZpbGw9IiMwMzE1MTQiLz4KPHBhdGggZD0iTTE3OTIgNjBDMTc5MiAyNi44NjI5IDE4MTguODYgMCAxODUyIDBIMjEyNkMyMTU5LjE0IDAgMjE4NiAyNi44NjI5IDIxODYgNjBWOTY2SDE3OTJWNjBaIiBmaWxsPSIjMDMxNTE0Ii8+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2kpIj4KPHBhdGggZD0iTTY3Mi4xMzMgMjMzOS42QzY2NS43OTYgMjMzOC4zNiA2NTkuOTYgMjM0My4zOSA2NjAuMzY1IDIzNDkuODRDNjgwLjQyOCAyNjY5LjMxIDk4MS45ODcgMjkyMi45MyAxMzUxLjA1IDI5MjIuOTNDMTcxOS4yNyAyOTIyLjkzIDIwMjAuMjkgMjY3MC40OCAyMDQxLjYgMjM1Mi4wNUMyMDQyLjAzIDIzNDUuNiAyMDM2LjIxIDIzNDAuNTQgMjAyOS44NyAyMzQxLjc2QzE4MTUuMDkgMjM4My4xMiAxNTg0IDI0MjMuNDIgMTM1MS4wNSAyNDIzLjQyQzExMTQuMDIgMjQyMy40MiA4ODkuODcgMjM4Mi4zNCA2NzIuMTMzIDIzMzkuNloiIGZpbGw9InVybCgjcGFpbnQ0X2xpbmVhcikiLz4KPC9nPgo8cGF0aCBkPSJNNzAzLjEwOSAyMzkwLjQyQzcxNC45OTEgMjQ5MC43OSAxMDA3LjQyIDI2MTMuMjkgMTM1NS40OSAyNjEzLjI5QzE3MDIuNzcgMjYxMy4yOSAxOTg5Ljc4IDI0OTAuNDggMjAwMi44NSAyMzkwLjQyQzE3OTkuNjggMjQwMy40MyAxNzgyLjk0IDI0NjguMTQgMTM1NS40OSAyNDY4LjE0QzkwNi4yNTUgMjQ2OC4xNCA5MDkuNDA2IDI0MDMuODYgNzAzLjEwOSAyMzkwLjQyWiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyKSIvPgo8cGF0aCBkPSJNMTI5OSAxNzM0Ljk1QzExOTcuNDMgMTkyMS40MSAxMDM4LjY2IDIxMDkuODQgODU1LjIzNCAyMTA0LjkxQzY2Ny44OCAyMTA0LjkxIDUxNiAxOTM5LjI3IDUxNiAxNzM0Ljk1QzUxNiAxNTMwLjYzIDY2Ny44OCAxMzY1IDg1NS4yMzQgMTM2NUMxMDQyLjU5IDEzNjUgMTE4MC42NiAxNTI4Ljc3IDEyOTkgMTczNC45NVoiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcikiLz4KPHBhdGggZD0iTTEzOTkgMTczNS40OUMxNTAwLjU3IDE5MTguMjQgMTY1OS4zNCAyMTA5Ljc1IDE4NDIuNzcgMjEwNC45MUMyMDMwLjEyIDIxMDQuOTEgMjE4MiAxOTM1Ljc1IDIxODIgMTczNS40OUMyMTgyIDE1MzUuMjMgMjAzMS4xMSAxMzY1IDE4NDMuNzUgMTM2NUMxNjU2LjQgMTM2NSAxNTE3LjM0IDE1MzMuNCAxMzk5IDE3MzUuNDlaIiBmaWxsPSJ1cmwoI3BhaW50N19saW5lYXIpIi8+CjxjaXJjbGUgY3g9Ijk4Ny41NDIiIGN5PSIxNzk3LjE4IiByPSI4OS4xNzQzIiBmaWxsPSIjMDMxNTE0Ii8+CjxjaXJjbGUgY3g9IjEwMTguNyIgY3k9IjE4MzYuOTQiIHI9IjMwLjA4MjkiIGZpbGw9IndoaXRlIi8+CjxjaXJjbGUgY3g9IjE3MTEuMzciIGN5PSIxNzk3LjE4IiByPSI4OS4xNzQzIiBmaWxsPSIjMDMxNTE0Ii8+CjxjaXJjbGUgY3g9IjE3NDIuNTMiIGN5PSIxODM2Ljk0IiByPSIzMC4wODI5IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMTMwMC44NyAxNzM4LjU4TDUxNy45NzIgMTc3OUM1MTYuMjgzIDE3NjQuMjEgNTE1LjAyMSAxNzU3LjMxIDUxNS4wMTkgMTc0Ni40N0M1MTMuMDQ3IDE1MjguNjEgNjY1Ljg4MyAxMzYzIDg1OC4xNTUgMTM2M0MxMDUwLjQzIDEzNjMgMTIwMC4yOSAxNTUzLjI2IDEyOTguOSAxNzMzLjY1QzEyOTguMDcgMTczNS4xNyAxMzAxLjcxIDE3MzcuMDYgMTMwMC44NyAxNzM4LjU4WiIgZmlsbD0iIzAzMTUxNCIvPgo8cGF0aCBkPSJNMTM5Ny4xMyAxNzM4LjU4TDIxODAuODMgMTc3OUMyMTgyLjUyIDE3NjQuMjEgMjE4Mi43OCAxNzU3LjMxIDIxODIuNzggMTc0Ni40N0MyMTg5LjcxIDE1MzIuNTUgMjAzMS45NSAxMzYzIDE4MzkuNzMgMTM2M0MxNjQ3LjUxIDEzNjMgMTQ5Ny42OCAxNTUzLjI2IDEzOTkuMSAxNzMzLjY1QzEzOTkuOTMgMTczNS4xNyAxMzk2LjI5IDE3MzcuMDYgMTM5Ny4xMyAxNzM4LjU4WiIgZmlsbD0iIzAzMTUxNCIvPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMV9pKSI+CjxwYXRoIGQ9Ik0xODM4LjE3IDEyNzJDMTU5OS40OSAxMjcyIDE0MjUuNzYgMTUxMC4zMyAxMzUwIDE2MzcuNTJDMTI3NC4yNCAxNTEwLjMzIDExMDAuNTEgMTI3MiA4NjEuODMxIDEyNzJDNjIwLjkyNyAxMjcyIDQyNSAxNDc5LjQ5IDQyNSAxNzM0LjVDNDI1IDE5ODkuNTEgNjIwLjkyNyAyMTk3IDg2MS44MzEgMjE5N0MxMTAwLjQ4IDIxOTcgMTI3NC4yNCAxOTU4LjY3IDEzNTAgMTgzMS40NUMxNDI1Ljc2IDE5NTguNjcgMTU5OS40OSAyMTk3IDE4MzguMTcgMjE5N0MyMDc5LjA3IDIxOTcgMjI3NSAxOTg5LjUxIDIyNzUgMTczNC41QzIyNzUgMTQ3OS40OSAyMDc5LjA3IDEyNzIgMTgzOC4xNyAxMjcyWk04NjEuODMxIDIxMDQuNUM2NzEuOTc1IDIxMDQuNSA1MTcuNSAxOTM4LjUyIDUxNy41IDE3MzQuNUM1MTcuNSAxNTMwLjQ4IDY3MS45NzUgMTM2NC41IDg2MS44MzEgMTM2NC41QzEwODcuMzkgMTM2NC41IDEyNTYuMzEgMTY1NS4zMyAxMjk4LjE0IDE3MzQuNUMxMjU2LjMxIDE4MTMuNjcgMTA4Ny40MiAyMTA0LjUgODYxLjgzMSAyMTA0LjVaTTE4MzguMTcgMjEwNC41QzE2MTIuNjEgMjEwNC41IDE0NDMuNjkgMTgxMy42NyAxNDAxLjg2IDE3MzQuNUMxNDQzLjY5IDE2NTUuMzMgMTYxMi42MSAxMzY0LjUgMTgzOC4xNyAxMzY0LjVDMjAyOC4wMyAxMzY0LjUgMjE4Mi41IDE1MzAuNDggMjE4Mi41IDE3MzQuNUMyMTgyLjUgMTkzOC41MiAyMDI4LjAzIDIxMDQuNSAxODM4LjE3IDIxMDQuNVoiIGZpbGw9InVybCgjcGFpbnQ4X2xpbmVhcikiLz4KPC9nPgo8ZGVmcz4KPGZpbHRlciBpZD0iZmlsdGVyMF9pIiB4PSI2NjAuMzQ1IiB5PSIyMzM5LjQxIiB3aWR0aD0iMTM4MS4yNyIgaGVpZ2h0PSI1ODMuNTIxIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQvPgo8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxNy41Ii8+CjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuNjQgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0ic2hhcGUiIHJlc3VsdD0iZWZmZWN0MV9pbm5lclNoYWRvdyIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyMV9pIiB4PSI0MjUiIHk9IjEyNzIiIHdpZHRoPSIxODUwIiBoZWlnaHQ9IjkyNSIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPgo8ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9IkJhY2tncm91bmRJbWFnZUZpeCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJzaGFwZSIvPgo8ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCIgcmVzdWx0PSJoYXJkQWxwaGEiLz4KPGZlT2Zmc2V0Lz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMTcuNSIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIi8+CjxmZUNvbG9yTWF0cml4IHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwLjY0IDAiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9InNoYXBlIiByZXN1bHQ9ImVmZmVjdDFfaW5uZXJTaGFkb3ciLz4KPC9maWx0ZXI+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhciIgeDE9IjE4MDEuNjkiIHkxPSIxODE2LjA2IiB4Mj0iMjc3My4wNCIgeTI9Ijg0My43MTgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzQ2RkY0NyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM5Q0ZGOUQiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyIiB4MT0iMTU2Ni45OSIgeTE9IjE3OTUuODEiIHgyPSIxODk2Ljc4IiB5Mj0iMTIyMy45IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMxMEQ5RUQiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTBEOUVEIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Ml9saW5lYXIiIHgxPSIxNDYwLjQ4IiB5MT0iMjAzOS41MiIgeDI9IjE2NDkuNzYiIHkyPSIxNTM1LjkxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGQTUxRDMiLz4KPHN0b3Agb2Zmc2V0PSIwLjk1ODc3NCIgc3RvcC1jb2xvcj0iI0ZBNTFEMyIgc3RvcC1vcGFjaXR5PSIwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQzX2xpbmVhciIgeDE9IjEwMDIuNSIgeTE9IjI4MjMiIHgyPSIxMzA2LjU0IiB5Mj0iMjAxMy4yNiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZFNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGRTcwMCIgc3RvcC1vcGFjaXR5PSIwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ0X2xpbmVhciIgeDE9IjEzNTEuMDEiIHkxPSIyMzM3LjE2IiB4Mj0iMTM1MS4wMSIgeTI9IjI5MjIuOTMiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3AvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3Atb3BhY2l0eT0iMC42NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXIiIHgxPSIxNTQwLjM1IiB5MT0iMjQyMS45NyIgeDI9IjE1NDAuMzUiIHkyPSIyNTc5Ljc2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC43NSIgc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjREVERURGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ2X2xpbmVhciIgeDE9IjEwMjAuMzgiIHkxPSIxNDY5Ljc4IiB4Mj0iMTAyMC4zNyIgeTI9IjE5OTMuNjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjc1IiBzdG9wLWNvbG9yPSJ3aGl0ZSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNERURFREYiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDdfbGluZWFyIiB4MT0iMTY3Ny42MiIgeTE9IjE0NjkuNzgiIHgyPSIxNjc3LjYzIiB5Mj0iMTk5My42NyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNzUiIHN0b3AtY29sb3I9IndoaXRlIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0RFREVERiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50OF9saW5lYXIiIHgxPSIxMzUwIiB5MT0iMTI3MiIgeDI9IjEzNTAiIHkyPSIyMTk3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9IjAuNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=",
};
const InternetIdentity = {
    id: "InternetIdentity",
    providerUrl: "",
    transportType: TransportType.INTERNET_IDENTITY,
    label: "Internet Identity",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzNTguOCAxNzkuOCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzU4LjggMTc5Ljg7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCNTVkdJRF8yXyk7fQoJLnN0MntmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOiMyOUFCRTI7fQo8L3N0eWxlPgo8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIyNC43ODUzIiB5MT0iMjU3Ljc1MzYiIHgyPSIzNDguMDY2MyIgeTI9IjEzMy40NTgxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMjcyKSI+Cgk8c3RvcCAgb2Zmc2V0PSIwLjIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjE1QTI0Ii8+Cgk8c3RvcCAgb2Zmc2V0PSIwLjY4NDEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkIwM0IiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI3MS42LDBjLTIwLDAtNDEuOSwxMC45LTY1LDMyLjRjLTEwLjksMTAuMS0yMC41LDIxLjEtMjcuNSwyOS44YzAsMCwxMS4yLDEyLjksMjMuNSwyNi44CgljNi43LTguNCwxNi4yLTE5LjgsMjcuMy0zMC4xYzIwLjUtMTkuMiwzMy45LTIzLjEsNDEuNi0yMy4xYzI4LjgsMCw1Mi4yLDI0LjIsNTIuMiw1NC4xYzAsMjkuNi0yMy40LDUzLjgtNTIuMiw1NC4xCgljLTEuNCwwLTMtMC4yLTUtMC42YzguNCwzLjksMTcuNSw2LjcsMjYsNi43YzUyLjgsMCw2My4yLTM2LjUsNjMuOC0zOS4xYzEuNS02LjcsMi40LTEzLjcsMi40LTIwLjlDMzU4LjYsNDAuNCwzMTkuNiwwLDI3MS42LDB6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMzLjk0NjEiIHkxPSIxMDYuNDI2MiIgeDI9IjEwLjY2NTMiIHkyPSIyMzAuNzIxNSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDI3MikiPgoJPHN0b3AgIG9mZnNldD0iMC4yMSIgc3R5bGU9InN0b3AtY29sb3I6I0VEMUU3OSIvPgoJPHN0b3AgIG9mZnNldD0iMC44OTI5IiBzdHlsZT0ic3RvcC1jb2xvcjojNTIyNzg1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik04Ny4xLDE3OS44YzIwLDAsNDEuOS0xMC45LDY1LTMyLjRjMTAuOS0xMC4xLDIwLjUtMjEuMSwyNy41LTI5LjhjMCwwLTExLjItMTIuOS0yMy41LTI2LjgKCWMtNi43LDguNC0xNi4yLDE5LjgtMjcuMywzMC4xYy0yMC41LDE5LTM0LDIzLjEtNDEuNiwyMy4xYy0yOC44LDAtNTIuMi0yNC4yLTUyLjItNTQuMWMwLTI5LjYsMjMuNC01My44LDUyLjItNTQuMQoJYzEuNCwwLDMsMC4yLDUsMC42Yy04LjQtMy45LTE3LjUtNi43LTI2LTYuN0MxMy40LDI5LjYsMyw2Ni4xLDIuNCw2OC44QzAuOSw3NS41LDAsODIuNSwwLDg5LjdDMCwxMzkuNCwzOSwxNzkuOCw4Ny4xLDE3OS44eiIvPgo8cGF0aCBjbGFzcz0ic3QyIiBkPSJNMTI3LjMsNTkuN2MtNS44LTUuNi0zNC0yOC41LTYxLTI5LjNDMTguMSwyOS4yLDQsNjQuMiwyLjcsNjguN0MxMiwyOS41LDQ2LjQsMC4yLDg3LjIsMAoJYzMzLjMsMCw2NywzMi43LDkxLjksNjIuMmMwLDAsMC4xLTAuMSwwLjEtMC4xYzAsMCwxMS4yLDEyLjksMjMuNSwyNi44YzAsMCwxNCwxNi41LDI4LjgsMzFjNS44LDUuNiwzMy45LDI4LjIsNjAuOSwyOQoJYzQ5LjUsMS40LDYzLjItMzUuNiw2My45LTM4LjRjLTkuMSwzOS41LTQzLjYsNjguOS04NC42LDY5LjFjLTMzLjMsMC02Ny0zMi43LTkyLTYyLjJjMCwwLjEtMC4xLDAuMS0wLjEsMC4yCgljMCwwLTExLjItMTIuOS0yMy41LTI2LjhDMTU2LjIsOTAuOCwxNDIuMiw3NC4yLDEyNy4zLDU5Ljd6IE0yLjcsNjkuMWMwLTAuMSwwLTAuMiwwLjEtMC4zQzIuNyw2OC45LDIuNyw2OSwyLjcsNjkuMXoiLz4KPC9zdmc+Cg==",
};
const Stoic = {
    id: "Stoic",
    providerUrl: "",
    transportType: TransportType.STOIC,
    label: "Stoic",
    icon: "data:image/png;base64,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",
};
({
    id: "OISY",
    label: "OISY",
    description: "A multi-chain wallet powered by chainfusion",
    providerUrl: "https://oisy.com/sign",
    transportType: TransportType.NEW_TAB,
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDQiIGhlaWdodD0iNDQiIHZpZXdCb3g9IjAgMCA0NCA0NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjIiIGN5PSIyMiIgcj0iMjIiIGZpbGw9IiMwMDY2RkYiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yNC40MTIgMzMuNDE5M0wyMy44ODI3IDM1Ljc2MDNDMjMuODAzNyAzNi4xMDk5IDIzLjQ2OTMgMzYuMzQwNSAyMy4xMTUyIDM2LjI4NThDMjIuMzA4IDM2LjE2MSAyMS40OSAzNi4wMTc3IDIwLjY2MzcgMzUuODU5NEMyMC4yODQyIDM1Ljc4NjcgMjAuMDQyMyAzNS40MTMzIDIwLjEyNzUgMzUuMDM2NUwyMC42MDY3IDMyLjkxN0MyMC4yNzExIDMyLjg1MTMgMTkuOTMzNCAzMi43ODAyIDE5LjU5NCAzMi43MDQyQzE5LjI4OCAzMi42MzQ0IDE4Ljk4NSAzMi41NjE1IDE4LjY4NTQgMzIuNDg1NUwxOC4yMDY0IDM0LjYwNDRDMTguMTIxMiAzNC45ODEgMTcuNzQyNiAzNS4yMTQgMTcuMzY4OSAzNS4xMTY4QzE2LjU1NDggMzQuOTA1IDE1Ljc1NDcgMzQuNjgzNiAxNC45NzIzIDM0LjQ1MDRDMTQuNjI4NCAzNC4zNDc5IDE0LjQyNTEgMzMuOTk1NSAxNC41MDQzIDMzLjY0NTVMMTUuMDMwOCAzMS4zMTY0QzkuODI2OTUgMjkuMjI5NyA2LjU0MTYxIDI1LjY4MyA3LjkzNjAzIDE5LjYyNjJMOC4yNzE1NiAxOC4xNDIxQzkuNjIwOTQgMTIuMDYyNiAxNC4xMTA5IDEwLjI4MTEgMTkuNzA1NiAxMC42MzkzTDIwLjIzMTggOC4zMTE3N0MyMC4zMTA5IDcuOTYxNzMgMjAuNjQ2IDcuNzMxMDUgMjEuMDAwNiA3Ljc4NjQ1QzIxLjgwNzIgNy45MTI0OSAyMi42MjQ3IDguMDU2ODMgMjMuNDUwNyA4LjIxNTkyQzIzLjgyOTkgOC4yODg5NSAyNC4wNzE0IDguNjYyMTMgMjMuOTg2MyA5LjAzODc1TDIzLjUwNzMgMTEuMTU3NUMyMy44MTA0IDExLjIxNzkgMjQuMTE1MyAxMS4yODI0IDI0LjQyMTUgMTEuMzUxMUMyNC43NjA5IDExLjQyNzggMjUuMDk2NSAxMS41MDgzIDI1LjQyNzcgMTEuNTkyN0wyNS45MDY1IDkuNDc1MUMyNS45OTE3IDkuMDk4MjYgMjYuMzcwNyA4Ljg2NTI4IDI2Ljc0NDUgOC45NjI4OUMyNy41NTg2IDkuMTc1NDQgMjguMzU4NiA5LjM5Nzg4IDI5LjE0MSA5LjYzMjQxQzI5LjQ4NDMgOS43MzUzNCAyOS42ODY5IDEwLjA4NzQgMjkuNjA3OSAxMC40MzdMMjkuMDgwMSAxMi43NzE3QzM0LjIxNjEgMTQuODU4IDM3LjQyNjEgMTguNDAyIDM2LjA2NDMgMjQuNDI1NkwzNS43Mjg4IDI1LjkwOTdDMzQuMzkwOSAzMS45Mzc2IDI5Ljk0OTIgMzMuNzQyMSAyNC40MTIgMzMuNDE5M1pNMzEuOTYyOSAyNC43MDM5TDMyLjE1MTcgMjMuODY4N0MzMy40ODE0IDE4LjM0MzQgMjkuMDYwMSAxNi4yNzk3IDIzLjYwOTQgMTQuOTY3NkMxOC4wOTg4IDEzLjgwMTUgMTMuMjE5NiAxMy43NjI2IDEyLjA0MzIgMTkuMzIyNkwxMS44NTQ0IDIwLjE1NzhDMTAuNTE4OSAyNS43MDg0IDE0Ljk0MDMgMjcuNzcyMSAyMC40MTY1IDI5LjA5QzI1LjkwMTYgMzAuMjUwMyAzMC43ODA3IDMwLjI4OTMgMzEuOTYyOSAyNC43MDM5WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==",
});

function useCreateIdentityKit({ selectedSigner, clearSigner, signerClientOptions = {}, authType, onConnectFailure, onConnectSuccess, realConnectDisabled, ...props }) {
    const [ik, setIk] = react.useState(null);
    const [user, setUser] = react.useState();
    const [icpBalance, setIcpBalance] = react.useState();
    const onDisconnect = react.useCallback(async () => {
        setIk(null);
        setUser(undefined);
        setIcpBalance(undefined);
        await selectedSigner?.transport.connection?.disconnect();
        await clearSigner();
        props.onDisconnect?.();
    }, [ik?.signerClient, clearSigner, props.onDisconnect]);
    // create disconnect func
    const disconnect = react.useCallback(async () => {
        return await ik?.signerClient?.logout();
    }, [ik?.signerClient]);
    // create fetchBalance func
    const fetchIcpBalance = react.useMemo(() => {
        if (!user || !ik)
            return;
        return () => ik.getIcpBalance().then(setIcpBalance);
    }, [ik, user, setIcpBalance]);
    react.useEffect(() => {
        setIk(null);
        // when signer is selected, but user is not connected, create indetity kit and trigger login
        if (selectedSigner && !ik?.signerClient) {
            IdentityKit.create({
                authType,
                signerClientOptions: {
                    ...signerClientOptions,
                    crypto,
                    signer: selectedSigner,
                    onLogout: onDisconnect,
                },
            }).then(async (instance) => {
                if (!realConnectDisabled) {
                    if (!instance.signerClient.connectedUser) {
                        try {
                            await instance.signerClient.login();
                            setUser(instance.signerClient.connectedUser);
                            onConnectSuccess?.();
                        }
                        catch (e) {
                            await clearSigner();
                            onConnectFailure?.(e);
                        }
                    }
                    else {
                        if (instance.signerClient.getIdentity?.() instanceof agent.AnonymousIdentity) {
                            await instance.signerClient.logout();
                            await disconnect();
                            return;
                        }
                        setUser(instance.signerClient.connectedUser);
                    }
                }
                else {
                    onConnectSuccess?.();
                }
                setIk(instance);
            });
        }
    }, [selectedSigner, realConnectDisabled]);
    // fetch balance when user connected
    react.useEffect(() => {
        if (icpBalance === undefined) {
            fetchIcpBalance?.();
        }
    }, [icpBalance, user, fetchIcpBalance]);
    return {
        user,
        disconnect,
        icpBalance,
        signerClient: ik?.signerClient,
        fetchIcpBalance,
    };
}

function useProceedTheme(theme = exports.IdentityKitTheme.SYSTEM) {
    const [finalTheme, setFinalTheme] = react.useState(theme);
    react.useEffect(() => {
        if (!theme || theme === exports.IdentityKitTheme.SYSTEM) {
            setFinalTheme(window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                ? exports.IdentityKitTheme.DARK
                : exports.IdentityKitTheme.LIGHT);
        }
        else {
            setFinalTheme(theme);
        }
    }, [theme]);
    return finalTheme;
}

const NEW_TAB_TRANSPORT_DEFAULT_ESTABLISH_TIMEOUT = 60000; // 1 min
async function getPopupTransportBuilder(options) {
    return new signerWeb.PostMessageTransport({
        ...options,
        detectNonClickEstablishment: false,
        statusPollingRate: 1000,
        disconnectTimeout: 5000,
        establishTimeout: NEW_TAB_TRANSPORT_DEFAULT_ESTABLISH_TIMEOUT, // 1 min
    });
}

async function getExtensionTransportBuilder({ uuid }) {
    return signerExtension.BrowserExtensionTransport.findTransport({ uuid });
}

async function getAuthClientTransportBuilder(options) {
    return await signerTransportAuthClient.AuthClientTransport.create({
        ...options,
        authClientCreateOptions: {
            ...options.authClientCreateOptions,
            idleOptions: {
                disableIdle: true,
            },
        },
    });
}

async function getStoicTransportBuilder({ maxTimeToLive, }) {
    return await signerTransportStoic.StoicTransport.create({ maxTimeToLive });
}

async function getPlugTransportBuilder() {
    return new signerTransportPlug.PlugTransport();
}

class TransportBuilder {
    static builders = {
        [TransportType.NEW_TAB]: ({ url, crypto, window }) => getPopupTransportBuilder({
            url,
            crypto,
            window,
        }),
        [TransportType.EXTENSION]: ({ id }) => {
            if (!id) {
                throw Error("Id is required to find the ICRC-94 specific wallet");
            }
            return getExtensionTransportBuilder({ uuid: id });
        },
        [TransportType.INTERNET_IDENTITY]: ({ maxTimeToLive, derivationOrigin, identity, keyType, storage, allowInternetIdentityPinAuthentication, url, }) => getAuthClientTransportBuilder({
            authClientCreateOptions: {
                identity,
                keyType,
                storage,
            },
            authClientLoginOptions: {
                maxTimeToLive,
                derivationOrigin,
                allowPinAuthentication: allowInternetIdentityPinAuthentication,
                identityProvider: url,
            },
        }),
        [TransportType.PLUG]: () => getPlugTransportBuilder(),
        [TransportType.STOIC]: ({ maxTimeToLive }) => getStoicTransportBuilder({ maxTimeToLive }),
    };
    static async build(request) {
        return await TransportBuilder.builders[request.transportType]({
            ...request,
            maxTimeToLive: request.maxTimeToLive || DEFAULT_MAX_TIME_TO_LIVE,
        });
    }
}

function useProceedSigner({ signers, closeModal, crypto, window, transportOptions, }) {
    // saved to local storage for next js (localStorage is not defined during server render)
    const [localStorageSigner, setLocalStorageSigner] = react.useState((typeof window !== "undefined" && localStorage.getItem("signerId")) || "");
    const [selectedSigner, setSelectedSigner] = react.useState(undefined);
    const selectSigner = react.useCallback(async (signerId) => {
        if (!signerId) {
            localStorage.removeItem("signerId");
            setLocalStorageSigner(undefined);
            return setSelectedSigner(undefined);
        }
        const signer$1 = signers.find((s) => s.id === signerId);
        if (!signer$1)
            throw new Error(`Signer with id ${signerId} not found`);
        const transport = await TransportBuilder.build({
            ...transportOptions,
            id: signer$1.id,
            transportType: signer$1.transportType,
            url: signer$1.providerUrl,
            crypto,
            window,
        });
        if (!transport.connection?.connected) {
            await transport.connection?.connect();
        }
        const createdSigner = new signer.Signer({
            crypto,
            transport,
        });
        setSelectedSigner({ signer: createdSigner, signerId });
        closeModal();
        return signer$1;
    }, [signers, crypto, closeModal]);
    const selectCustomSigner = react.useCallback(async (url) => {
        const transport = await TransportBuilder.build({
            transportType: TransportType.NEW_TAB,
            url,
            crypto,
            window,
        });
        const createdSigner = new signer.Signer({ crypto, transport });
        setSelectedSigner({ signer: createdSigner });
        closeModal();
    }, [crypto, window, closeModal]);
    // default selected signer from local storage
    react.useEffect(() => {
        // for next.js, where localStorage is not available during ssr
        const lsSigner = localStorage.getItem("signerId");
        if (!selectedSigner && lsSigner) {
            selectSigner(lsSigner);
        }
    }, [selectedSigner, selectSigner]);
    const setSelectedSignerToLocalStorage = react.useCallback(() => {
        if (selectedSigner && selectedSigner.signerId) {
            localStorage.setItem("signerId", selectedSigner.signerId);
        }
    }, [selectedSigner]);
    const memoizedSelectedSigner = react.useMemo(() => selectedSigner?.signer, [selectedSigner]);
    return {
        selectSigner,
        setSelectedSignerToLocalStorage,
        // clears both local state and local storage
        clearSigner: () => selectSigner(),
        selectCustomSigner,
        // selected signer is local storage signer by default (in case authenticated user)
        selectedSigner: memoizedSelectedSigner,
        // signer id in localStorage (used on connected user page reload)
        localStorageSigner,
    };
}

class ContextNotInitializedError extends Error {
    constructor() {
        super("IdentityKit context not initialized");
    }
}

function useBalance() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return {
            balance: ctx.icpBalance,
            fetchBalance: ctx.fetchIcpBalance,
        };
    });
}

function useSigner() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.selectedSigner;
    });
}

function useModal() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return {
            isModalOpen: ctx.isModalOpen,
            toggleModal: ctx.toggleModal,
            featuredSigner: ctx.featuredSigner,
            signers: ctx.signers,
            selectCustomSigner: ctx.selectCustomSigner,
            selectSigner: ctx.selectSigner,
        };
    });
}

function useTheme() {
    return react.useContext(ThemeContext);
}

function useAuthType() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.authType;
    });
}

function useUser() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.user;
    });
}

function useSignerClient() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.signerClient;
    });
}

function useIsInitializing() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.isInitializing;
    });
}

function useIsUserConnecting() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.isUserConnecting;
    });
}

function useConnect() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.connect;
    });
}

function useDisconnect() {
    return useContextSelector.useContextSelector(Context, (ctx) => {
        if (!ctx)
            throw new ContextNotInitializedError();
        return ctx.disconnect;
    });
}

function useDelegationType() {
    const signerClient = useSignerClient();
    const authType = useAuthType();
    const user = useUser();
    const delegationType = useAsyncMemo.useAsyncMemo(() => {
        if (!user ||
            !signerClient ||
            authType !== IdentityKitAuthType.DELEGATION ||
            signerClient instanceof AccountsSignerClient)
            return undefined;
        return signerClient.getDelegationType();
    }, [user, authType, signerClient]);
    return delegationType;
}

function useAccounts() {
    const authType = useAuthType();
    const signerClient = useSignerClient();
    const user = useUser();
    const [accounts, setAccounts] = react.useState();
    react.useEffect(() => {
        if (!user) {
            setAccounts(undefined);
        }
        else {
            if (authType === IdentityKitAuthType.ACCOUNTS &&
                !accounts &&
                signerClient instanceof AccountsSignerClient) {
                signerClient?.getAccounts().then(setAccounts);
            }
        }
    }, [user, authType, signerClient]);
    return accounts;
}

/**
 * @deprecated This function is deprecated. Please use separate hooks instead (useUser, useBalance etc).
 */
function useIdentityKit() {
    const ctx = useContextSelector.useContext(Context);
    if (!ctx) {
        throw new ContextNotInitializedError();
    }
    const { selectedSigner, user, icpBalance, authType, isInitializing, isUserConnecting, connect, disconnect, fetchIcpBalance, } = ctx;
    const identity = useIdentity();
    const delegationType = useDelegationType();
    const accounts = useAccounts();
    return {
        signer: selectedSigner,
        user,
        icpBalance,
        authType,
        accounts,
        delegationType,
        identity,
        isInitializing,
        isUserConnecting,
        connect,
        disconnect,
        fetchIcpBalance,
    };
}

function useIdentity() {
    const signerClient = useSignerClient();
    const authType = useAuthType();
    const identity = react.useMemo(() => authType === IdentityKitAuthType.ACCOUNTS || signerClient instanceof AccountsSignerClient
        ? undefined
        : signerClient?.getIdentity(), [authType, signerClient]);
    return identity;
}

function useAgent(agentOptions = {}) {
    const identity = useIdentity();
    const selectedSigner = useSigner();
    const user = useUser();
    const signerClient = useSignerClient();
    const authType = useAuthType();
    const ikAgent = useAsyncMemo.useAsyncMemo(async () => {
        if (!selectedSigner || !user || !signerClient)
            return undefined;
        const isAccountsAuth = authType === IdentityKitAuthType.ACCOUNTS;
        if (!isAccountsAuth && !identity)
            return undefined;
        const delegation = isAccountsAuth
            ? undefined
            : await signerClient.getDelegation();
        const defaultAgent = await agent.HttpAgent.create({
            identity,
            ...agentOptions,
        });
        const signerAgent$1 = await signerAgent.SignerAgent.create({
            signer: selectedSigner,
            account: user.principal,
            agent: defaultAgent,
        });
        return Agent.create({
            signerAgent: signerAgent$1,
            agent: defaultAgent,
            identity,
            delegation: delegation?.delegation,
        });
    }, [selectedSigner, signerClient, authType, identity]);
    return ikAgent;
}

function useClickOutside(handler) {
    const ref = react.useRef(null);
    react.useEffect(() => {
        const listener = (event) => {
            const el = ref?.current;
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(event.target))
                return;
            handler(event);
        };
        document.addEventListener(`mousedown`, listener);
        document.addEventListener(`touchstart`, listener);
        return () => {
            document.removeEventListener(`mousedown`, listener);
            document.removeEventListener(`touchstart`, listener);
        };
    }, [ref, handler]);
    return ref;
}

function useAuth() {
    const user = useUser();
    const isConnecting = useIsUserConnecting();
    const connect = useConnect();
    const disconnect = useDisconnect();
    return {
        user,
        isConnecting,
        connect,
        disconnect,
    };
}

function useCreatePromise() {
    // Internal state to force re-renders when the promise resolves
    const [, setResolvedValue] = react.useState();
    // Store the promise and its resolve/reject handlers in a ref
    const promiseRef = react.useRef({
        promise: null,
        resolve: null,
        reject: null,
    });
    // Create the promise
    const createPromise = react.useCallback(() => {
        promiseRef.current.promise = new Promise((resolve, reject) => {
            promiseRef.current.resolve = resolve;
            promiseRef.current.reject = reject;
        });
        return promiseRef.current.promise;
    }, []);
    // Resolve the promise
    const resolve = react.useCallback((value) => {
        if (promiseRef.current.resolve) {
            promiseRef.current.resolve(value);
            setResolvedValue(value); // Trigger re-render
        }
    }, []);
    // Reject the promise
    const reject = react.useCallback((error) => {
        if (promiseRef.current.reject) {
            promiseRef.current.reject(error);
            setResolvedValue(undefined); // Trigger re-render (optional)
        }
    }, []);
    return { createPromise, resolve, reject, promise: promiseRef.current.promise };
}

function ThemeProvider({ children, ...props }) {
    const theme = useProceedTheme(props.theme);
    return jsxRuntime.jsx(ThemeContext.Provider, { value: theme, children: children });
}

const validateUrl = (url) => {
    const urlPattern = new RegExp("^(https?:\\/\\/)?" +
        "((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|" +
        "((\\d{1,3}\\.){3}\\d{1,3}))" +
        "(\\:\\d+)?" +
        "(\\/[-a-z\\d%_.~+]*)*" +
        "(\\?[;&a-z\\d%_.~+=-]*)?" +
        "(\\#[-a-z\\d_]*)?$", "i");
    return urlPattern.test(url);
};

const ICP_DECIMALS = 8;
function countDecimals(value) {
    if (Math.floor(value) === value)
        return 0;
    const str = value.toString();
    if (str.indexOf(".") !== -1 && str.indexOf("-") !== -1) {
        return Number(str.split("-")[1]);
    }
    else if (str.indexOf(".") !== -1) {
        return Number(str.split(".")[1].length);
    }
    return Number(str.split("-")[1]);
}
function formatIcp(value) {
    if (!value)
        return value.toString();
    const decimals = countDecimals(value);
    const formattedValue = value.toFixed(decimals > ICP_DECIMALS ? ICP_DECIMALS : decimals);
    if (!Number(formattedValue))
        return "0";
    return formattedValue;
}

const Spinner = ({ className }) => {
    return (jsxRuntime.jsxs("svg", { className: clsx("animate-spin", "ik-h-5 ik-w-5", className), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [jsxRuntime.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), jsxRuntime.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }));
};

const getButtonClassName = ({ className, type = "primary", block, large, }) => clsx(type === "primary"
    ? "ik-component ik-border-transparent ik-bg-primary ik-text-white hover:ik-bg-teal-600 active:ik-bg-teal-700 active:ik-border-primary hover:ik-shadow-md ik-font-bold ik-px-[10px] ik-min-w-[140px] ik-h-[40px] ik-flex ik-items-center ik-justify-center ik-px-[15px] ik-rounded-xl border"
    : "ik-component ik-border-transparent", "ik-bg-gray-200 ik-text-black hover:ik-bg-gray-100 active:ik-bg-gray-300 active:ik-border-gray-200 hover:ik-shadow-md ik-font-bold ik-px-[10px] ik-min-w-[140px] ik-h-[40px] ik-flex ik-items-center ik-justify-center ik-px-[15px] ik-rounded-xl ik-border", {
    "disabled:ik-shadow-none disabled:ik-bg-gray-300 disabled:ik-border-gray-300 dark:disabled:ik-bg-zinc-700 dark:disabled:ik-border-zinc-700": type === "primary",
    "ik-w-full ik-block": block,
    "ik-h-[48px]": large,
}, className);
const Button$1 = ({ children, className, disabled, loading, icon, id, block, large, type = "primary", as: Component = "button", ...buttonProps }) => {
    return (jsxRuntime.jsx(Component, { id: id, disabled: disabled || loading, className: getButtonClassName({ className, type, block, large }), ...buttonProps, children: jsxRuntime.jsxs("div", { className: "ik-flex ik-items-center ik-justify-center ik-space-x-2", children: [loading ? (jsxRuntime.jsx(Spinner, { className: "mr-1 text-white" })) : icon ? (jsxRuntime.jsx("div", { className: "ik-flex ik-items-center ik-justify-center ik-w-6 ik-h-6", children: icon })) : null, children ? jsxRuntime.jsx("div", { className: "ik-text-center", children: children }) : null] }) }));
};

function ConnectButton({ onClick, className, disabled, loading, children, }) {
    return (jsxRuntime.jsx(Button$1, { id: "connect", disabled: disabled, loading: loading, onClick: onClick, className: className, children: children ?? jsxRuntime.jsx("small", { children: "Connect wallet" }) }));
}

function Item({ className, children, ...props }) {
    return (jsxRuntime.jsx("div", { className: clsx("ik-component ik-flex ik-justify-between ik-w-full ik-p-2.5 ik-text-black dark:ik-text-white ik-cursor-pointer", className), ...props, children: children }));
}

function ItemText(props) {
    return (jsxRuntime.jsx("small", { ...props, className: clsx("ik-component ik-font-semibold ik-text-black dark:ik-text-white", props.className) }));
}

function Items({ className, innerClassName, children, ...props }) {
    const theme = useTheme();
    const menuItems = !Array.isArray(children) ? [children] : children;
    return (jsxRuntime.jsx(react$1.MenuItems, { anchor: "bottom end", transition: true, "data-identity-kit-theme": theme, className: clsx("ik-min-w-[320px] ik-rounded-3xl ik-bg-white dark:ik-bg-zinc-900 ik-shadow-lg ik-transition focus:ik-outline-none data-[closed]:ik-scale-95 data-[closed]:ik-transform data-[closed]:ik-opacity-0 data-[enter]:ik-duration-100 data-[leave]:ik-duration-75 data-[enter]:ik-ease-out data-[leave]:ik-ease-in ik-p-2.5 [--anchor-gap:8px] ik-z-[999]", className), ...props, children: jsxRuntime.jsx("div", { className: clsx("ik-py-1", innerClassName), children: menuItems }) }));
}

function CopyToClipboard({ component: Component, onCopied, onCopiedTimeout, value, }) {
    const [clicked, setClicked] = react.useState(false);
    return (jsxRuntime.jsx(Component, { onClick: () => {
            if (clicked)
                return;
            setClicked(true);
            setTimeout(() => {
                setClicked(false);
                onCopiedTimeout?.();
            }, 1000);
            navigator.clipboard.writeText(value);
            onCopied?.();
        } }));
}

function Copy(props) {
    const theme = useTheme();
    return (jsxRuntime.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsxRuntime.jsx("path", { d: "M11.7795 5.55534V5.55534C11.7795 4.727 11.7795 4.31283 11.6442 3.98612C11.4638 3.55052 11.1177 3.20443 10.6821 3.024C10.3554 2.88867 9.94119 2.88867 9.11285 2.88867H6.44618C4.77008 2.88867 3.93202 2.88867 3.41132 3.40937C2.89062 3.93007 2.89062 4.76812 2.89062 6.44423V9.1109C2.89062 9.93924 2.89062 10.3534 3.02595 10.6801C3.20638 11.1157 3.55247 11.4618 3.98808 11.6422C4.31478 11.7776 4.72895 11.7776 5.55729 11.7776V11.7776", stroke: theme === exports.IdentityKitTheme.DARK ? colors.white : colors.black, strokeWidth: "1.8" }), jsxRuntime.jsx("rect", { x: "8.22266", y: "8.22266", width: "8.88889", height: "8.88889", rx: "1.77778", stroke: theme === exports.IdentityKitTheme.DARK ? colors.white : colors.black, strokeWidth: "1.8" })] }));
}

function Logout(props) {
    const theme = useTheme();
    return (jsxRuntime.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsxRuntime.jsx("path", { d: "M9.99996 2.5L9.16663 2.5C6.8096 2.5 5.63109 2.5 4.89886 3.23223C4.16663 3.96447 4.16663 5.14298 4.16663 7.5L4.16663 12.5C4.16663 14.857 4.16663 16.0355 4.89886 16.7678C5.63109 17.5 6.8096 17.5 9.16663 17.5L9.99996 17.5", stroke: theme === exports.IdentityKitTheme.DARK ? colors.white : colors.black, strokeWidth: "1.8", strokeLinecap: "round" }), jsxRuntime.jsx("path", { d: "M13.0209 6.25L16.7709 10M16.7709 10L13.0209 13.75M16.7709 10L9.27087 10", stroke: theme === exports.IdentityKitTheme.DARK ? colors.white : colors.black, strokeWidth: "1.8", strokeLinecap: "round" })] }));
}

function Copied(props) {
    return (jsxRuntime.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsxRuntime.jsx("path", { d: "M11.7795 5.55534V5.55534C11.7795 4.727 11.7795 4.31283 11.6442 3.98612C11.4638 3.55052 11.1177 3.20443 10.6821 3.024C10.3554 2.88867 9.94119 2.88867 9.11285 2.88867H6.44618C4.77008 2.88867 3.93202 2.88867 3.41132 3.40937C2.89062 3.93007 2.89062 4.76812 2.89062 6.44423V9.1109C2.89062 9.93924 2.89062 10.3534 3.02595 10.6801C3.20638 11.1157 3.55247 11.4618 3.98808 11.6422C4.31478 11.7776 4.72895 11.7776 5.55729 11.7776V11.7776", stroke: colors.green[500], strokeWidth: "1.8" }), jsxRuntime.jsx("path", { d: "M11.332 12.2222L13.2544 14L17.1098 10", stroke: colors.green[500], strokeWidth: "1.8", strokeLinecap: "round" }), jsxRuntime.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M18.0131 13.4522V13.6147C18.0132 14.4022 18.0132 15.0818 17.94 15.6262C17.8615 16.2101 17.6843 16.7714 17.2288 17.2269C16.7734 17.6823 16.2121 17.8595 15.6282 17.938C15.0837 18.0112 14.4041 18.0112 13.6167 18.0112H11.7207C10.9332 18.0112 10.2536 18.0112 9.70915 17.938C9.12524 17.8595 8.56397 17.6823 8.10853 17.2269C7.65308 16.7714 7.47584 16.2101 7.39734 15.6262C7.32414 15.0818 7.32418 14.4022 7.32422 13.6147L7.32422 13.5556V11.7778L7.32422 11.7187C7.32418 10.9312 7.32414 10.2516 7.39734 9.7072C7.47584 9.12328 7.65308 8.56201 8.10853 8.10657C8.56397 7.65113 9.12524 7.47389 9.70915 7.39538C10.2536 7.32218 10.9332 7.32222 11.7207 7.32227L11.7798 7.32227H13.5576L13.6167 7.32227C14.3298 7.32223 14.9545 7.32219 15.4705 7.37656L13.7581 9.12233C13.6932 9.12228 13.6263 9.12227 13.5576 9.12227H11.7798C10.9163 9.12227 10.3592 9.12418 9.949 9.17933C9.56468 9.231 9.44658 9.31411 9.38132 9.37936C9.31606 9.44462 9.23295 9.56273 9.18129 9.94704C9.12613 10.3572 9.12422 10.9143 9.12422 11.7778V13.5556C9.12422 14.4191 9.12613 14.9762 9.18129 15.3864C9.23295 15.7707 9.31606 15.8888 9.38132 15.9541C9.44658 16.0193 9.56468 16.1024 9.949 16.1541C10.3592 16.2092 10.9163 16.2112 11.7798 16.2112H13.5576C14.4211 16.2112 14.9781 16.2092 15.3883 16.1541C15.7727 16.1024 15.8908 16.0193 15.956 15.9541C16.0213 15.8888 16.1044 15.7707 16.1561 15.3864C16.1569 15.3799 16.1578 15.3733 16.1586 15.3668L16.3425 15.1756L17.3496 14.1286L18.0131 13.4522Z", fill: colors.green[500] })] }));
}

const VISIBLE_ADDRESS_CHARS_NUMBER = 5;
function AddressItem({ value, onClick, ...props }) {
    const [connectedAddressCopied, setConnectedAddressCopied] = react.useState(false);
    return (jsxRuntime.jsx(CopyToClipboard, { value: value, onCopied: () => setConnectedAddressCopied(true), onCopiedTimeout: () => setConnectedAddressCopied(false), component: (componentProps) => (jsxRuntime.jsxs(Item, { onClick: (e) => {
                componentProps.onClick();
                onClick?.(e);
            }, ...props, className: clsx("ik-component", props.className), children: [jsxRuntime.jsx(ItemText, { children: "Wallet address" }), jsxRuntime.jsxs("div", { className: "ik-flex", children: [jsxRuntime.jsx("small", { className: "ik-font-semibold", children: `${value.substring(0, VISIBLE_ADDRESS_CHARS_NUMBER)}...${value.substring(value.length - VISIBLE_ADDRESS_CHARS_NUMBER)}` }), connectedAddressCopied ? (jsxRuntime.jsx(Copied, { className: "ik-ml-2" })) : (jsxRuntime.jsx(Copy, { className: "ik-ml-2" }))] })] })) }));
}

function DisconnectItem(props) {
    return (jsxRuntime.jsxs(Item, { ...props, className: clsx("ik-component", props.className), children: [jsxRuntime.jsx(ItemText, { children: "Disconnect" }), jsxRuntime.jsx(Logout, {})] }));
}

function Menu({ className, children, ...props }) {
    return (jsxRuntime.jsx(react$1.Menu, { as: "div", className: clsx("ik-component ik-inline-block ik-text-left", className), ...props, children: children }));
}

function Button({ className, ...props }) {
    return jsxRuntime.jsx(react$1.MenuButton, { ...props, className: clsx("ik-component", className) });
}

function ConnectedButton({ connectedAccount, icpBalance, className, children, ...props }) {
    return (jsxRuntime.jsx(Button, { id: "connect", type: "button", ...props, className: getButtonClassName({ className: className, type: "secondary" }), children: children ? (children) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("small", { className: "ik-mr-2", children: [connectedAccount.substring(0, 5), "...", connectedAccount.substring(connectedAccount.length - 5)] }), jsxRuntime.jsx("div", { className: "ik-bg-white ik-px-[5px] ik-rounded-md", children: jsxRuntime.jsx("small", { className: "ik-text-black ik-font-normal ik-text-xs", children: icpBalance !== undefined && `${formatIcp(icpBalance)} ICP` }) })] })) }));
}

function ConnectWallet({ connectButtonComponent, connectedButtonComponent, dropdownMenuComponent, }) {
    const connect = useConnect();
    const disconnect = useDisconnect();
    const user = useUser();
    const { balance } = useBalance();
    const isInitializing = useIsInitializing();
    const isUserConnecting = useIsUserConnecting();
    const ConnectButtonComponent = connectButtonComponent ?? ConnectButton;
    const ConnectedButtonComponent = connectedButtonComponent ?? ConnectedButton;
    const DropdownMenuComponent = dropdownMenuComponent ?? Menu;
    if (!user)
        return (jsxRuntime.jsx(ConnectButtonComponent, { onClick: () => connect(), disabled: isInitializing, loading: isUserConnecting }));
    const connectedAccount = user.principal.toString();
    const props = { disconnect, icpBalance: balance, connectedAccount };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(DropdownMenuComponent, { ...(dropdownMenuComponent
                ? props
                : {}), children: [jsxRuntime.jsx(ConnectedButtonComponent, { connectedAccount: connectedAccount, icpBalance: balance }), jsxRuntime.jsxs(Items, { children: [jsxRuntime.jsx(AddressItem, { value: connectedAccount }), jsxRuntime.jsx(DisconnectItem, { onClick: disconnect })] })] }) }));
}

const Tooltip = ({ tip, children, className, ...contentProps }) => {
    return (jsxRuntime.jsxs(RadixTooltip__namespace.Root, { children: [jsxRuntime.jsx(RadixTooltip__namespace.Trigger, { asChild: true, children: children }), jsxRuntime.jsx(RadixTooltip__namespace.Portal, { children: jsxRuntime.jsxs(RadixTooltip__namespace.Content, { sideOffset: 5, className: clsx("ik-text-white ik-text-sm ik-font-light ik-bg-black ik-py-2 ik-px-6 ik-rounded", className, ["left", "right"].includes(contentProps.side || "top") ? "ik-my-2" : "ik-mx-2"), ...contentProps, children: [tip, jsxRuntime.jsx(RadixTooltip__namespace.Arrow, { className: "ik-fill-current ik-text-black" })] }) })] }));
};

const Header = ({ onBack, isViewAll }) => {
    return (jsxRuntime.jsxs("div", { className: "ik-flex ik-items-center ik-justify-between", children: [jsxRuntime.jsxs("div", { className: "ik-flex ik-items-center ik-gap-[10px]", children: [isViewAll && (jsxRuntime.jsxs("svg", { "data-testid": "svg", onClick: onBack, className: "ik-text-black ik-cursor-pointer dark:ik-text-white", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("path", { d: "M18.7272 11.864L4.99932 11.864", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("path", { d: "M11.6562 18.5207L4.9994 11.8639L11.6562 5.20703", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" })] })), jsxRuntime.jsx("p", { className: clsx("ik-font-bold ik-text-black dark:ik-text-white"), children: "Connect your wallet" })] }), jsxRuntime.jsx(Tooltip, { align: "end", side: "bottom", tip: jsxRuntime.jsxs("div", { className: "ik-text-white ik-leading-[16px]", children: [jsxRuntime.jsx("div", { className: "ik-text-sm ik-font-bold", children: "What is a Wallet?" }), jsxRuntime.jsx("div", { className: "ik-text-xs ik-font-bold ik-mt-[12px]", children: "A home for digital assets" }), jsxRuntime.jsx("p", { className: "ik-text-xs", children: "Wallets are used to send, receive, store, and display digital assets." }), jsxRuntime.jsx("div", { className: "ik-text-xs ik-font-bold ik-mt-[12px]", children: "A new way to sign in" }), jsxRuntime.jsx("p", { className: "ik-text-xs", children: "Instead of creating new accounts and passwords on every website, just connect your wallet instead." })] }), className: "ik-px-3 ik-bg-black ik-w-[320px] ik-z-[1011] -mr-[15px]", children: jsxRuntime.jsxs("svg", { className: "ik-cursor-pointer", "data-testid": "info", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("path", { d: "M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z", stroke: "#9CA3AF", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("path", { d: "M12 16.125V11.3125", stroke: "#9CA3AF", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("path", { d: "M12 7.875H12.0092", stroke: "#9CA3AF", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" })] }) })] }));
};

const CustomSignerInput = ({ onSubmit }) => {
    const [value, setValue] = react.useState("");
    const isValueValid = !value || validateUrl(value);
    return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("div", { className: "ik-text-black dark:ik-text-white ik-font-bold ik-my-[20px]", children: "CustomConnect" }), jsxRuntime.jsxs("div", { className: "ik-flex ik-items-center ik-gap-[12px] ik-relative", children: [jsxRuntime.jsx("input", { className: "ik-rounded-xl ik-border ik-border-gray-400 ik-px-[10px] ik-h-[48px] ik-flex-1 ik-flex-shrink ik-text-sm ik-text-black focus:ik-border-gray-400 ik-outline-none", placeholder: "https://wallet.url", type: "text", value: value, onChange: (e) => {
                            setValue(e.target.value);
                        }, name: "url" }), jsxRuntime.jsx(Button$1, { large: true, disabled: !value || !isValueValid, className: "ik-w-[110px]", onClick: () => onSubmit(value), children: jsxRuntime.jsx("small", { children: "Connect" }) })] }), !!value && !isValueValid && (jsxRuntime.jsx("p", { className: "ik-text-xs ik-text-red-500 ik-block ik-mt-1", children: "Invalid url" }))] }));
};

const SelectWalletList = ({ signers, onSelectSigner, isViewAll, onViewAll, featuredSigner, onCustomSignerSelect, }) => {
    return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("div", { className: "ik-flex ik-flex-col ik-gap-2 ik-relative ik-overflow-auto ik-max-h-[420px]", children: signers.map((signer) => (jsxRuntime.jsx("div", { className: clsx("ik-shadow-[0px_2px_10px_rgba(0,0,0,0.03)] ik-rounded-[13px]", featuredSigner?.id === signer.id
                        ? "ik-gradient-border"
                        : "ik-border ik-border-black/5 dark:ik-border-white/5"), children: jsxRuntime.jsxs("div", { id: `signer_${signer.id}`, className: clsx("ik-bg-white dark:ik-bg-zinc-800 ik-rounded-[12px] ik-cursor-pointer", "hover:ik-bg-gray-50 dark:hover:ik-bg-signerDarkHoverBg", "ik-flex ik-items-center ik-space-x-3 ik-w-full ik-p-5", featuredSigner?.id === signer.id && signer?.description?.length && "!ik-items-start"), onClick: async () => {
                            await onSelectSigner(signer.id);
                        }, children: [jsxRuntime.jsx("img", { src: signer.icon, alt: signer.label, className: "ik-w-8 ik-h-8" }), jsxRuntime.jsxs("div", { className: "ik-text-black dark:ik-text-white", children: [jsxRuntime.jsx("p", { className: "ik-text-sm ik-font-bold ik-leading-[25px]", children: signer.label }), featuredSigner?.id === signer.id && signer.description && (jsxRuntime.jsx("p", { className: "ik-text-xs ik-text-gray-400 dark:ik-text-zinc-400 ik-leading-[20px]", children: signer.description }))] })] }) }, `signer_${signer.id}`))) }), !isViewAll ? (jsxRuntime.jsx("div", { className: "ik-flex ik-py-3.5 ik-mt-2", children: jsxRuntime.jsx("small", { onClick: onViewAll, className: "ik-text-primary dark:ik-text-teal-500 ik-font-bold ik-cursor-pointer ik-mx-auto ik-block", children: "View all" }) })) : (jsxRuntime.jsx(CustomSignerInput, { onSubmit: onCustomSignerSelect }))] }));
};

const Modal = () => {
    const { isModalOpen, toggleModal, signers, selectSigner, selectCustomSigner, featuredSigner } = useModal();
    const theme = useTheme();
    const [isViewAll, setIsViewAll] = react.useState(false);
    const ref = useClickOutside(() => {
        if (isModalOpen)
            toggleModal();
    });
    react.useEffect(() => {
        setTimeout(() => {
            if (!isModalOpen) {
                document.body.removeAttribute("data-scroll-locked");
            }
            document.body.style.pointerEvents = isModalOpen ? "none" : "";
            document.body.style.userSelect = isModalOpen ? "none" : "";
            document.body.style.overflow = isModalOpen ? "hidden" : "";
        }, 0);
    }, [isModalOpen]);
    const sortedSigners = react.useMemo(() => {
        return signers.sort((a, b) => {
            if (a.id === featuredSigner?.id)
                return -1;
            if (b.id === featuredSigner?.id)
                return 1;
            return 0;
        });
    }, [signers, featuredSigner]);
    return (jsxRuntime.jsx(RadixTooltip.TooltipProvider, { children: jsxRuntime.jsx(Dialog__namespace.Root, { open: true, children: jsxRuntime.jsxs(Dialog__namespace.Portal, { children: [jsxRuntime.jsx("div", { className: clsx(isModalOpen ? "ik-block" : "ik-hidden", "ik-component ik-bg-black ik-bg-opacity-25 ik-backdrop-blur-[2px]", "ik-fixed ik-inset-0 ik-z-[1009]") }), jsxRuntime.jsxs(Dialog__namespace.Content, { ref: ref, id: "ik-identity-kit-modal", "data-identity-kit-theme": theme, "aria-describedby": undefined, className: clsx("ik-component ik-flex-col ik-fixed ik-p-0 focus:ik-outline-none ik-z-[1010]", "ik-shadow-lg", "ik-top-[50%] ik-left-[50%] ik-max-h-[85vh] ik-w-[90vw] ik-max-w-[490px] ik-translate-x-[-50%] ik-translate-y-[-50%]", isModalOpen ? "ik-flex" : "ik-hidden"), children: [jsxRuntime.jsx(Dialog__namespace.Title, { className: "ik-hidden", children: "Select signer" }), jsxRuntime.jsxs("div", { className: clsx("ik-flex ik-flex-col ik-rounded-xl ik-h-full", "ik-bg-[#FAFAFA] dark:ik-bg-black", "ik-p-[20px] ik-gap-[10px]"), children: [jsxRuntime.jsx(Header, { onBack: () => setIsViewAll(false), isViewAll: isViewAll }), jsxRuntime.jsx(SelectWalletList, { signers: sortedSigners, featuredSigner: featuredSigner, onSelectSigner: selectSigner, isViewAll: isViewAll, onViewAll: () => setIsViewAll(true), onCustomSignerSelect: (url) => {
                                            if (!url)
                                                return;
                                            selectCustomSigner(url);
                                        } })] })] })] }) }) }));
};

globalThis.global = globalThis;
const Provider = ({ children, signerClientOptions = {}, crypto = globalThis.crypto, window = globalThis.window, authType = IdentityKitAuthType.DELEGATION, realConnectDisabled, allowInternetIdentityPinAuthentication, discoverExtensionSigners = true, ...props }) => {
    const [isModalOpen, setIsModalOpen] = react.useState(false);
    const { createPromise, resolve, reject } = useCreatePromise();
    const toggleModal = () => {
        setIsModalOpen((prev) => !prev);
    };
    const { maxTimeToLive, keyType, storage, identity } = signerClientOptions;
    const { signers, featuredSigner } = react.useMemo(() => {
        const signersList = !props.signers || !props.signers.length
            ? [NFIDW, Plug, InternetIdentity, Stoic]
            : props.signers;
        const selectedFeaturedSigner = props.featuredSigner === false ? undefined : (props.featuredSigner ?? signersList[0]);
        return {
            signers: signersList,
            featuredSigner: selectedFeaturedSigner,
        };
    }, [props.signers, props.featuredSigner, signerClientOptions]);
    const [discoveredSigners, setDiscoveredSigners] = react.useState([]);
    react.useEffect(() => {
        if (!discoverExtensionSigners) {
            return;
        }
        signerExtension.BrowserExtensionTransport.discover().then((providerDetails) => {
            setDiscoveredSigners(providerDetails.map((providerDetail) => ({
                id: providerDetail.uuid,
                providerUrl: "",
                label: providerDetail.name,
                transportType: TransportType.EXTENSION,
                icon: providerDetail.icon,
            })));
        });
    }, [discoverExtensionSigners]);
    const signersIncludingDiscovered = react.useMemo(() => [...signers, ...discoveredSigners], [signers, discoveredSigners]);
    const { selectSigner, clearSigner, selectedSigner, localStorageSigner, selectCustomSigner, setSelectedSignerToLocalStorage, } = useProceedSigner({
        signers: signersIncludingDiscovered,
        closeModal: () => setIsModalOpen(false),
        crypto,
        window,
        transportOptions: {
            maxTimeToLive,
            derivationOrigin: signerClientOptions.derivationOrigin,
            allowInternetIdentityPinAuthentication,
            keyType,
            storage,
            identity,
        },
    });
    const onConnectSuccess = react.useCallback(() => {
        setSelectedSignerToLocalStorage();
        resolve();
    }, [setSelectedSignerToLocalStorage, resolve]);
    const identityKit = useCreateIdentityKit({
        selectedSigner,
        clearSigner,
        signerClientOptions: { ...signerClientOptions, crypto },
        authType,
        onConnectSuccess,
        onConnectFailure: reject,
        onDisconnect: props.onDisconnect,
        realConnectDisabled,
    });
    const isInitializing = react.useMemo(() => !!localStorageSigner && !identityKit.user, [localStorageSigner, identityKit.user]);
    const isUserConnecting = react.useMemo(() => !!selectedSigner && !identityKit.user, [selectedSigner, identityKit.user]);
    const connect = react.useCallback(async (signerIdOrUrl) => {
        if (isInitializing)
            throw new Error("Identitykit is not initialized yet");
        if (!signerIdOrUrl)
            setIsModalOpen(true);
        else {
            if (signers.find((s) => s.id === signerIdOrUrl))
                await selectSigner(signerIdOrUrl);
            else {
                if (!validateUrl(signerIdOrUrl))
                    throw new Error("Provided value is not valid signer id or url");
                await selectCustomSigner(signerIdOrUrl);
            }
        }
        return createPromise()
            .then(() => {
            props.onConnectSuccess?.();
        })
            .catch((e) => {
            if (props.onConnectFailure) {
                props.onConnectFailure(e);
            }
            else {
                throw e;
            }
        });
    }, [isInitializing, signers]);
    return (jsxRuntime.jsx(Context.Provider, { value: {
            signers: signersIncludingDiscovered,
            selectedSigner,
            isModalOpen,
            featuredSigner,
            user: identityKit.user,
            icpBalance: identityKit.icpBalance,
            authType,
            signerClient: identityKit.signerClient,
            isInitializing,
            isUserConnecting,
            toggleModal,
            selectSigner,
            selectCustomSigner,
            connect,
            disconnect: identityKit.disconnect,
            fetchIcpBalance: identityKit.fetchIcpBalance,
        }, children: jsxRuntime.jsxs(ThemeProvider, { theme: props.theme, children: [jsxRuntime.jsx(Modal, {}), children] }) }));
};

exports.ConnectWallet = ConnectWallet;
exports.ConnectWalletButton = ConnectButton;
exports.ConnectWalletDropdownMenu = Menu;
exports.ConnectWalletDropdownMenuAddressItem = AddressItem;
exports.ConnectWalletDropdownMenuButton = Button;
exports.ConnectWalletDropdownMenuDisconnectItem = DisconnectItem;
exports.ConnectWalletDropdownMenuItem = Item;
exports.ConnectWalletDropdownMenuItems = Items;
exports.ConnectedWalletButton = ConnectedButton;
exports.DEFAULT_SIZES = DEFAULT_SIZES;
exports.IdentityKitProvider = Provider;
exports.formatIcp = formatIcp;
exports.useAccounts = useAccounts;
exports.useAgent = useAgent;
exports.useAuth = useAuth;
exports.useBalance = useBalance;
exports.useDelegationType = useDelegationType;
exports.useIdentity = useIdentity;
exports.useIdentityKit = useIdentityKit;
exports.useIsInitializing = useIsInitializing;
exports.useSigner = useSigner;
