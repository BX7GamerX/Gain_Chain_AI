{"version":3,"file":"authClientConnection.js","sourceRoot":"","sources":["../../src/authClientConnection.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,OAAO,EAAE,wBAAwB,EAAE,MAAM,uBAAuB,CAAC;AACjE,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,MAAM,mBAAmB,CAAC;AAmB1E,MAAM,OAAO,oBAAoB;IAK/B,YAAY,OAAoC;;QAJhD,gDAAgD;QAChD,oDAAuB,IAAI,GAAG,EAAc,EAAC;QAC7C,kEAA4D;QAG1D,uBAAA,IAAI,iDACF,sBAAsB,EAAE,EAAE,EAC1B,sCAAsC,EAAE,IAAI,IACzC,OAAO,OACX,CAAC;QACF,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,uBAAA,IAAI,gFAAmB,MAAvB,IAAI,CAAqB,CAAC;QAC5B,CAAC;IACH,CAAC;IAED,IAAI,SAAS;QACX,MAAM,QAAQ,GAAG,uBAAA,IAAI,qCAAS,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;QACxD,IAAI,QAAQ,CAAC,YAAY,EAAE,CAAC,WAAW,EAAE,EAAE,CAAC;YAC1C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,kBAAkB,GAAG,QAA8B,CAAC;QAC1D,OAAO,iBAAiB,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC,CAAC;IAC/D,CAAC;IAED,KAAK,CAAC,OAAO;QACX,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC3C,uBAAA,IAAI,qCAAS,CAAC,UAAU,CAAC,KAAK,iCACzB,uBAAA,IAAI,qCAAS,CAAC,sBAAsB,KACvC,SAAS,EAAE,GAAG,EAAE;oBACd,uBAAA,IAAI,gFAAmB,MAAvB,IAAI,CAAqB,CAAC;oBAC1B,OAAO,EAAE,CAAC;gBACZ,CAAC,EACD,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE,CACjB,MAAM,CACJ,IAAI,wBAAwB,CAAC,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,yBAAyB,CAAC,CACjE,IACH,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,UAAU;QACd,aAAa,CAAC,uBAAA,IAAI,uDAA2B,CAAC,CAAC;QAC/C,MAAM,uBAAA,IAAI,qCAAS,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;QACxC,uBAAA,IAAI,iDAAqB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED,gBAAgB,CAAC,KAAmB,EAAE,QAAoB;QACxD,QAAQ,KAAK,EAAE,CAAC;YACd,KAAK,YAAY;gBACf,uBAAA,IAAI,iDAAqB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACxC,OAAO,GAAG,EAAE;oBACV,uBAAA,IAAI,iDAAqB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAC7C,CAAC,CAAC;QACN,CAAC;IACH,CAAC;CAUF;;IAPG,uBAAA,IAAI,mDAA8B,WAAW,CAAC,GAAG,EAAE;QACjD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,uBAAA,IAAI,iDAAqB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;YAC5D,aAAa,CAAC,uBAAA,IAAI,uDAA2B,CAAC,CAAC;QACjD,CAAC;IACH,CAAC,EAAE,uBAAA,IAAI,qCAAS,CAAC,sCAAsC,CAAC,MAAA,CAAC;AAC3D,CAAC","sourcesContent":["import type { Connection } from \"@slide-computer/signer\";\nimport { AuthClientTransportError } from \"./authClientTransport\";\nimport { DelegationIdentity, isDelegationValid } from \"@dfinity/identity\";\nimport type { AuthClient, AuthClientLoginOptions } from \"@dfinity/auth-client\";\n\ninterface AuthClientConnectionOptions {\n  /**\n   * AuthClient instance from \"@dfinity/auth-client\"\n   */\n  authClient: AuthClient;\n  /**\n   * Login options used to log in with AuthClient instance\n   */\n  authClientLoginOptions?: AuthClientLoginOptions;\n  /**\n   * Auth Client disconnect monitoring interval in ms\n   * @default 3000\n   */\n  authClientDisconnectMonitoringInterval?: number;\n}\n\nexport class AuthClientConnection implements Connection {\n  #options: Required<AuthClientConnectionOptions>;\n  #disconnectListeners = new Set<() => void>();\n  #disconnectMonitorInterval?: ReturnType<typeof setInterval>;\n\n  constructor(options: AuthClientConnectionOptions) {\n    this.#options = {\n      authClientLoginOptions: {},\n      authClientDisconnectMonitoringInterval: 3000,\n      ...options,\n    };\n    if (this.connected) {\n      this.#monitorDisconnect();\n    }\n  }\n\n  get connected() {\n    const identity = this.#options.authClient.getIdentity();\n    if (identity.getPrincipal().isAnonymous()) {\n      return false;\n    }\n    const delegationIdentity = identity as DelegationIdentity;\n    return isDelegationValid(delegationIdentity.getDelegation());\n  }\n\n  async connect(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.#options.authClient.login({\n        ...this.#options.authClientLoginOptions,\n        onSuccess: () => {\n          this.#monitorDisconnect();\n          resolve();\n        },\n        onError: (error) =>\n          reject(\n            new AuthClientTransportError(error ?? \"AuthClient login failed\"),\n          ),\n      });\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    clearInterval(this.#disconnectMonitorInterval);\n    await this.#options.authClient.logout();\n    this.#disconnectListeners.forEach((listener) => listener());\n  }\n\n  addEventListener(event: \"disconnect\", listener: () => void): () => void {\n    switch (event) {\n      case \"disconnect\":\n        this.#disconnectListeners.add(listener);\n        return () => {\n          this.#disconnectListeners.delete(listener);\n        };\n    }\n  }\n\n  #monitorDisconnect() {\n    this.#disconnectMonitorInterval = setInterval(() => {\n      if (!this.connected) {\n        this.#disconnectListeners.forEach((listener) => listener());\n        clearInterval(this.#disconnectMonitorInterval);\n      }\n    }, this.#options.authClientDisconnectMonitoringInterval);\n  }\n}\n"]}