"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _SignerAgent_isInternalConstructing, _SignerAgent_options, _SignerAgent_certificates, _SignerAgent_queue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignerAgent = exports.SignerAgentError = void 0;
const agent_1 = require("@dfinity/agent");
const candid_1 = require("@dfinity/candid");
const principal_1 = require("@dfinity/principal");
const signer_1 = require("@slide-computer/signer");
const utils_1 = require("./utils");
const queue_1 = require("./queue");
const MAX_AGE_IN_MINUTES = 5;
const INVALID_RESPONSE_MESSAGE = "Received invalid response from signer";
class SignerAgentError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, SignerAgentError.prototype);
    }
}
exports.SignerAgentError = SignerAgentError;
class SignerAgent {
    constructor(options) {
        _SignerAgent_options.set(this, void 0);
        _SignerAgent_certificates.set(this, new Map());
        _SignerAgent_queue.set(this, new queue_1.Queue());
        const throwError = !__classPrivateFieldGet(_a, _a, "f", _SignerAgent_isInternalConstructing);
        __classPrivateFieldSet(_a, _a, false, "f", _SignerAgent_isInternalConstructing);
        if (throwError) {
            throw new SignerAgentError("SignerAgent is not constructable");
        }
        __classPrivateFieldSet(this, _SignerAgent_options, options, "f");
    }
    get rootKey() {
        return __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.rootKey;
    }
    get signer() {
        return __classPrivateFieldGet(this, _SignerAgent_options, "f").signer;
    }
    static async create(options) {
        var _b;
        __classPrivateFieldSet(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
        return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : (await agent_1.HttpAgent.create()) }));
    }
    static createSync(options) {
        var _b;
        __classPrivateFieldSet(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
        return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : agent_1.HttpAgent.createSync() }));
    }
    async call(canisterId, options) {
        // Make sure canisterId is a principal
        canisterId = principal_1.Principal.from(canisterId);
        // Manually open the transport channel here first to make sure that
        // the async queue does not e.g. block a popup window from opening.
        await __classPrivateFieldGet(this, _SignerAgent_options, "f").signer.openChannel();
        // Make call through signer with an async queue, this makes sure that even when a developer
        // makes multiple calls in parallel with Promise.all(), they are forced to execute in sequence.
        const response = await __classPrivateFieldGet(this, _SignerAgent_queue, "f").schedule(() => __classPrivateFieldGet(this, _SignerAgent_options, "f").signer.callCanister({
            canisterId,
            sender: __classPrivateFieldGet(this, _SignerAgent_options, "f").account,
            method: options.methodName,
            arg: options.arg,
        }));
        // Validate content map
        const requestBody = (0, utils_1.decodeCallRequest)(response.contentMap);
        const contentMapMatchesRequest = agent_1.SubmitRequestType.Call === requestBody.request_type &&
            canisterId.compareTo(requestBody.canister_id) === "eq" &&
            options.methodName === requestBody.method_name &&
            (0, agent_1.compare)(options.arg, requestBody.arg) === 0 &&
            __classPrivateFieldGet(this, _SignerAgent_options, "f").account.compareTo(principal_1.Principal.from(requestBody.sender)) ===
                "eq";
        if (!contentMapMatchesRequest) {
            throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
        }
        // Validate certificate
        const requestId = (0, agent_1.requestIdOf)(requestBody);
        const certificate = await agent_1.Certificate.create({
            certificate: response.certificate,
            rootKey: this.rootKey,
            canisterId,
            maxAgeInMinutes: MAX_AGE_IN_MINUTES,
        }).catch(() => {
            throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
        });
        const certificateIsResponseToContentMap = certificate.lookup(["request_status", requestId, "status"]).status ===
            agent_1.LookupStatus.Found;
        if (!certificateIsResponseToContentMap) {
            throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
        }
        // Check if response has already been received previously to avoid replay attacks
        const requestKey = (0, signer_1.toBase64)(requestId);
        if (__classPrivateFieldGet(this, _SignerAgent_certificates, "f").has(requestKey)) {
            throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
        }
        // Store certificate in map
        __classPrivateFieldGet(this, _SignerAgent_certificates, "f").set(requestKey, response.certificate);
        // Cleanup when certificate expires
        const now = Date.now();
        const lookupTime = (0, agent_1.lookupResultToBuffer)(certificate.lookup(["time"]));
        if (!lookupTime) {
            throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
        }
        const certificateTime = Number((0, candid_1.lebDecode)(new candid_1.PipeArrayBuffer(lookupTime))) / 1000000;
        const expiry = certificateTime - now + MAX_AGE_IN_MINUTES * 60 * 1000;
        setTimeout(() => __classPrivateFieldGet(this, _SignerAgent_certificates, "f").delete(requestKey), expiry);
        // Return request id with http response
        return {
            requestId,
            response: {
                ok: true,
                status: 202,
                statusText: "Call has been sent over ICRC-25 JSON-RPC",
                body: null,
                headers: [],
            },
        };
    }
    async fetchRootKey() {
        return __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.fetchRootKey();
    }
    async getPrincipal() {
        return __classPrivateFieldGet(this, _SignerAgent_options, "f").account;
    }
    async query(canisterId, options) {
        // Make sure canisterId is a principal
        canisterId = principal_1.Principal.from(canisterId);
        // Upgrade query request to a call sent through signer
        const submitResponse = await this.call(canisterId, options);
        const readStateResponse = await this.readState(canisterId, {
            paths: [
                [new TextEncoder().encode("request_status"), submitResponse.requestId],
            ],
        });
        const certificate = await agent_1.Certificate.create({
            certificate: readStateResponse.certificate,
            rootKey: this.rootKey,
            canisterId,
        });
        const status = certificate.lookup([
            "request_status",
            submitResponse.requestId,
            "status",
        ]);
        const reply = certificate.lookup([
            "request_status",
            submitResponse.requestId,
            "reply",
        ]);
        if (status.status !== agent_1.LookupStatus.Found ||
            new TextDecoder().decode(status.value) !== "replied" ||
            reply.status !== agent_1.LookupStatus.Found) {
            throw new SignerAgentError("Certificate is missing reply");
        }
        return {
            requestId: submitResponse.requestId,
            status: "replied",
            reply: {
                arg: reply.value,
            },
            httpDetails: {
                ok: true,
                status: 202,
                statusText: "Certificate with reply has been received over ICRC-25 JSON-RPC",
                headers: [],
            },
        };
    }
    async createReadStateRequest(_options) {
        // Since request is typed as any it shouldn't need any data,
        // but since agent-js 2.1.3 this would cause a runtime error.
        return {
            body: {
                content: {},
            },
        };
    }
    async readState(_canisterId, options, _identity, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _request) {
        if (options.paths.length !== 1 ||
            options.paths[0].length !== 2 ||
            new TextDecoder().decode(options.paths[0][0]) !== "request_status") {
            throw new SignerAgentError("Given paths are not supported");
        }
        const requestId = options.paths[0][1];
        const key = (0, signer_1.toBase64)(requestId);
        const certificate = __classPrivateFieldGet(this, _SignerAgent_certificates, "f").get(key);
        if (!certificate) {
            throw new SignerAgentError("Certificate could not be found");
        }
        return { certificate };
    }
    async status() {
        return __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.status();
    }
    replaceAccount(account) {
        __classPrivateFieldGet(this, _SignerAgent_options, "f").account = account;
    }
}
exports.SignerAgent = SignerAgent;
_a = SignerAgent, _SignerAgent_options = new WeakMap(), _SignerAgent_certificates = new WeakMap(), _SignerAgent_queue = new WeakMap();
// noinspection JSUnusedLocalSymbols
_SignerAgent_isInternalConstructing = { value: false };
//# sourceMappingURL=agent.js.map