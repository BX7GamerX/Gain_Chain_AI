{"version":3,"file":"agent.js","sourceRoot":"","sources":["../../src/agent.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,0CAiBwB;AACxB,4CAA8E;AAC9E,kDAA+C;AAC/C,mDAA+D;AAC/D,mCAA4C;AAC5C,mCAAgC;AAEhC,MAAM,kBAAkB,GAAG,CAAC,CAAC;AAC7B,MAAM,wBAAwB,GAAG,uCAAuC,CAAC;AAkBzE,MAAa,gBAAiB,SAAQ,KAAK;IACzC,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAC1D,CAAC;CACF;AALD,4CAKC;AAED,MAAa,WAAW;IAUtB,YAAoB,OAAwC;QAJnD,uCAA0C;QAC1C,oCAAgB,IAAI,GAAG,EAAuB,EAAC;QAC/C,6BAAS,IAAI,aAAK,EAAE,EAAC;QAG5B,MAAM,UAAU,GAAG,CAAC,uBAAA,EAAW,+CAAwB,CAAC;QACxD,uBAAA,EAAW,MAA2B,KAAK,2CAAA,CAAC;QAC5C,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,IAAI,gBAAgB,CAAC,kCAAkC,CAAC,CAAC;QACjE,CAAC;QACD,uBAAA,IAAI,wBAAY,OAAO,MAAA,CAAC;IAC1B,CAAC;IAED,IAAI,OAAO;QACT,OAAO,uBAAA,IAAI,4BAAS,CAAC,KAAK,CAAC,OAAO,CAAC;IACrC,CAAC;IAED,IAAI,MAAM;QACR,OAAO,uBAAA,IAAI,4BAAS,CAAC,MAAM,CAAC;IAC9B,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,MAAM,CACjB,OAA8B;;QAE9B,uBAAA,EAAW,MAA2B,IAAI,2CAAA,CAAC;QAC3C,OAAO,IAAI,EAAW,iCACjB,OAAO,KACV,KAAK,EAAE,MAAA,OAAO,CAAC,KAAK,mCAAI,CAAC,MAAM,iBAAS,CAAC,MAAM,EAAE,CAAC,IAClD,CAAC;IACL,CAAC;IAED,MAAM,CAAC,UAAU,CACf,OAA8B;;QAE9B,uBAAA,EAAW,MAA2B,IAAI,2CAAA,CAAC;QAC3C,OAAO,IAAI,EAAW,iCACjB,OAAO,KACV,KAAK,EAAE,MAAA,OAAO,CAAC,KAAK,mCAAI,iBAAS,CAAC,UAAU,EAAE,IAC9C,CAAC;IACL,CAAC;IAED,KAAK,CAAC,IAAI,CACR,UAA8B,EAC9B,OAIC;QAED,sCAAsC;QACtC,UAAU,GAAG,qBAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAExC,mEAAmE;QACnE,mEAAmE;QACnE,MAAM,uBAAA,IAAI,4BAAS,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;QAEzC,2FAA2F;QAC3F,+FAA+F;QAC/F,MAAM,QAAQ,GAAG,MAAM,uBAAA,IAAI,0BAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,CAC/C,uBAAA,IAAI,4BAAS,CAAC,MAAM,CAAC,YAAY,CAAC;YAChC,UAAU;YACV,MAAM,EAAE,uBAAA,IAAI,4BAAS,CAAC,OAAO;YAC7B,MAAM,EAAE,OAAO,CAAC,UAAU;YAC1B,GAAG,EAAE,OAAO,CAAC,GAAG;SACjB,CAAC,CACH,CAAC;QAEF,uBAAuB;QACvB,MAAM,WAAW,GAAG,IAAA,yBAAiB,EAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC3D,MAAM,wBAAwB,GAC5B,yBAAiB,CAAC,IAAI,KAAK,WAAW,CAAC,YAAY;YACnD,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,IAAI;YACtD,OAAO,CAAC,UAAU,KAAK,WAAW,CAAC,WAAW;YAC9C,IAAA,eAAO,EAAC,OAAO,CAAC,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC;YAC3C,uBAAA,IAAI,4BAAS,CAAC,OAAO,CAAC,SAAS,CAAC,qBAAS,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;gBACjE,IAAI,CAAC;QACT,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC9B,MAAM,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;QACvD,CAAC;QAED,uBAAuB;QACvB,MAAM,SAAS,GAAG,IAAA,mBAAW,EAAC,WAAW,CAAC,CAAC;QAC3C,MAAM,WAAW,GAAG,MAAM,mBAAW,CAAC,MAAM,CAAC;YAC3C,WAAW,EAAE,QAAQ,CAAC,WAAW;YACjC,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,UAAU;YACV,eAAe,EAAE,kBAAkB;SACpC,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE;YACZ,MAAM,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;QACH,MAAM,iCAAiC,GACrC,WAAW,CAAC,MAAM,CAAC,CAAC,gBAAgB,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC,MAAM;YAClE,oBAAY,CAAC,KAAK,CAAC;QACrB,IAAI,CAAC,iCAAiC,EAAE,CAAC;YACvC,MAAM,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;QACvD,CAAC;QAED,iFAAiF;QACjF,MAAM,UAAU,GAAG,IAAA,iBAAQ,EAAC,SAAS,CAAC,CAAC;QACvC,IAAI,uBAAA,IAAI,iCAAc,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;YACvC,MAAM,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;QACvD,CAAC;QAED,2BAA2B;QAC3B,uBAAA,IAAI,iCAAc,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;QAEzD,mCAAmC;QACnC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,UAAU,GAAG,IAAA,4BAAoB,EAAC,WAAW,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACtE,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,MAAM,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;QACvD,CAAC;QACD,MAAM,eAAe,GACnB,MAAM,CAAC,IAAA,kBAAS,EAAC,IAAI,wBAAe,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,OAAS,CAAC;QACjE,MAAM,MAAM,GAAG,eAAe,GAAG,GAAG,GAAG,kBAAkB,GAAG,EAAE,GAAG,IAAI,CAAC;QACtE,UAAU,CAAC,GAAG,EAAE,CAAC,uBAAA,IAAI,iCAAc,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC;QAEhE,uCAAuC;QACvC,OAAO;YACL,SAAS;YACT,QAAQ,EAAE;gBACR,EAAE,EAAE,IAAI;gBACR,MAAM,EAAE,GAAG;gBACX,UAAU,EAAE,0CAA0C;gBACtD,IAAI,EAAE,IAAI;gBACV,OAAO,EAAE,EAAE;aACZ;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,YAAY;QAChB,OAAO,uBAAA,IAAI,4BAAS,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC;IAC5C,CAAC;IAED,KAAK,CAAC,YAAY;QAChB,OAAO,uBAAA,IAAI,4BAAS,CAAC,OAAO,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,KAAK,CACT,UAA8B,EAC9B,OAAoB;QAEpB,sCAAsC;QACtC,UAAU,GAAG,qBAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAExC,sDAAsD;QACtD,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAC5D,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE;YACzD,KAAK,EAAE;gBACL,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,cAAc,CAAC,SAAS,CAAC;aACvE;SACF,CAAC,CAAC;QACH,MAAM,WAAW,GAAG,MAAM,mBAAW,CAAC,MAAM,CAAC;YAC3C,WAAW,EAAE,iBAAiB,CAAC,WAAW;YAC1C,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,UAAU;SACX,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;YAChC,gBAAgB;YAChB,cAAc,CAAC,SAAS;YACxB,QAAQ;SACT,CAAC,CAAC;QACH,MAAM,KAAK,GAAG,WAAW,CAAC,MAAM,CAAC;YAC/B,gBAAgB;YAChB,cAAc,CAAC,SAAS;YACxB,OAAO;SACR,CAAC,CAAC;QACH,IACE,MAAM,CAAC,MAAM,KAAK,oBAAY,CAAC,KAAK;YACpC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,KAAoB,CAAC,KAAK,SAAS;YACnE,KAAK,CAAC,MAAM,KAAK,oBAAY,CAAC,KAAK,EACnC,CAAC;YACD,MAAM,IAAI,gBAAgB,CAAC,8BAA8B,CAAC,CAAC;QAC7D,CAAC;QACD,OAAO;YACL,SAAS,EAAE,cAAc,CAAC,SAAS;YACnC,MAAM,EAAE,SAAwC;YAChD,KAAK,EAAE;gBACL,GAAG,EAAE,KAAK,CAAC,KAAoB;aAChC;YACD,WAAW,EAAE;gBACX,EAAE,EAAE,IAAI;gBACR,MAAM,EAAE,GAAG;gBACX,UAAU,EACR,gEAAgE;gBAClE,OAAO,EAAE,EAAE;aACZ;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,sBAAsB,CAC1B,QAA0B;QAG1B,4DAA4D;QAC5D,6DAA6D;QAC7D,OAAO;YACL,IAAI,EAAE;gBACJ,OAAO,EAAE,EAAE;aACZ;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,SAAS,CACb,WAA+B,EAC/B,OAAyB,EACzB,SAAwC;IACxC,8DAA8D;IAC9D,QAAc;QAEd,IACE,OAAO,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;YAC1B,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC;YAC7B,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,gBAAgB,EAClE,CAAC;YACD,MAAM,IAAI,gBAAgB,CAAC,+BAA+B,CAAC,CAAC;QAC9D,CAAC;QACD,MAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAc,CAAC;QACnD,MAAM,GAAG,GAAG,IAAA,iBAAQ,EAAC,SAAS,CAAC,CAAC;QAChC,MAAM,WAAW,GAAG,uBAAA,IAAI,iCAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAChD,IAAI,CAAC,WAAW,EAAE,CAAC;YACjB,MAAM,IAAI,gBAAgB,CAAC,gCAAgC,CAAC,CAAC;QAC/D,CAAC;QACD,OAAO,EAAE,WAAW,EAAE,CAAC;IACzB,CAAC;IAED,KAAK,CAAC,MAAM;QACV,OAAO,uBAAA,IAAI,4BAAS,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;IACtC,CAAC;IAED,cAAc,CAAC,OAAkB;QAC/B,uBAAA,IAAI,4BAAS,CAAC,OAAO,GAAG,OAAO,CAAC;IAClC,CAAC;;AA9OH,kCA+OC;;AA3OC,oCAAoC;AAC7B,+CAAmC,KAAK,EAAjB,CAAkB","sourcesContent":["import {\n  type Agent,\n  type ApiQueryResponse,\n  Certificate,\n  compare,\n  HttpAgent,\n  type Identity,\n  lookupResultToBuffer,\n  LookupStatus,\n  type QueryFields,\n  type QueryResponseStatus,\n  type ReadStateOptions,\n  type ReadStateResponse,\n  type RequestId,\n  requestIdOf,\n  SubmitRequestType,\n  type SubmitResponse,\n} from \"@dfinity/agent\";\nimport { type JsonObject, lebDecode, PipeArrayBuffer } from \"@dfinity/candid\";\nimport { Principal } from \"@dfinity/principal\";\nimport { type Signer, toBase64 } from \"@slide-computer/signer\";\nimport { decodeCallRequest } from \"./utils\";\nimport { Queue } from \"./queue\";\n\nconst MAX_AGE_IN_MINUTES = 5;\nconst INVALID_RESPONSE_MESSAGE = \"Received invalid response from signer\";\n\nexport interface SignerAgentOptions<T extends Pick<Signer, \"callCanister\">> {\n  /**\n   * Signer instance that should be used to send ICRC-25 JSON-RPC messages\n   */\n  signer: T;\n  /**\n   * Principal of account that should be used to make calls\n   */\n  account: Principal;\n  /**\n   * Optional, used to fetch root key\n   * @default uses {@link HttpAgent} by default\n   */\n  agent?: HttpAgent;\n}\n\nexport class SignerAgentError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, SignerAgentError.prototype);\n  }\n}\n\nexport class SignerAgent<\n  T extends Pick<Signer, \"callCanister\" | \"openChannel\"> = Signer,\n> implements Agent\n{\n  // noinspection JSUnusedLocalSymbols\n  static #isInternalConstructing: boolean = false;\n  readonly #options: Required<SignerAgentOptions<T>>;\n  readonly #certificates = new Map<string, ArrayBuffer>();\n  readonly #queue = new Queue();\n\n  private constructor(options: Required<SignerAgentOptions<T>>) {\n    const throwError = !SignerAgent.#isInternalConstructing;\n    SignerAgent.#isInternalConstructing = false;\n    if (throwError) {\n      throw new SignerAgentError(\"SignerAgent is not constructable\");\n    }\n    this.#options = options;\n  }\n\n  get rootKey() {\n    return this.#options.agent.rootKey;\n  }\n\n  get signer(): T {\n    return this.#options.signer;\n  }\n\n  static async create<T extends Pick<Signer, \"callCanister\" | \"openChannel\">>(\n    options: SignerAgentOptions<T>,\n  ) {\n    SignerAgent.#isInternalConstructing = true;\n    return new SignerAgent<T>({\n      ...options,\n      agent: options.agent ?? (await HttpAgent.create()),\n    });\n  }\n\n  static createSync<T extends Pick<Signer, \"callCanister\" | \"openChannel\">>(\n    options: SignerAgentOptions<T>,\n  ) {\n    SignerAgent.#isInternalConstructing = true;\n    return new SignerAgent<T>({\n      ...options,\n      agent: options.agent ?? HttpAgent.createSync(),\n    });\n  }\n\n  async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n    },\n  ): Promise<SubmitResponse> {\n    // Make sure canisterId is a principal\n    canisterId = Principal.from(canisterId);\n\n    // Manually open the transport channel here first to make sure that\n    // the async queue does not e.g. block a popup window from opening.\n    await this.#options.signer.openChannel();\n\n    // Make call through signer with an async queue, this makes sure that even when a developer\n    // makes multiple calls in parallel with Promise.all(), they are forced to execute in sequence.\n    const response = await this.#queue.schedule(() =>\n      this.#options.signer.callCanister({\n        canisterId,\n        sender: this.#options.account,\n        method: options.methodName,\n        arg: options.arg,\n      }),\n    );\n\n    // Validate content map\n    const requestBody = decodeCallRequest(response.contentMap);\n    const contentMapMatchesRequest =\n      SubmitRequestType.Call === requestBody.request_type &&\n      canisterId.compareTo(requestBody.canister_id) === \"eq\" &&\n      options.methodName === requestBody.method_name &&\n      compare(options.arg, requestBody.arg) === 0 &&\n      this.#options.account.compareTo(Principal.from(requestBody.sender)) ===\n        \"eq\";\n    if (!contentMapMatchesRequest) {\n      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);\n    }\n\n    // Validate certificate\n    const requestId = requestIdOf(requestBody);\n    const certificate = await Certificate.create({\n      certificate: response.certificate,\n      rootKey: this.rootKey,\n      canisterId,\n      maxAgeInMinutes: MAX_AGE_IN_MINUTES,\n    }).catch(() => {\n      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);\n    });\n    const certificateIsResponseToContentMap =\n      certificate.lookup([\"request_status\", requestId, \"status\"]).status ===\n      LookupStatus.Found;\n    if (!certificateIsResponseToContentMap) {\n      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);\n    }\n\n    // Check if response has already been received previously to avoid replay attacks\n    const requestKey = toBase64(requestId);\n    if (this.#certificates.has(requestKey)) {\n      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);\n    }\n\n    // Store certificate in map\n    this.#certificates.set(requestKey, response.certificate);\n\n    // Cleanup when certificate expires\n    const now = Date.now();\n    const lookupTime = lookupResultToBuffer(certificate.lookup([\"time\"]));\n    if (!lookupTime) {\n      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);\n    }\n    const certificateTime =\n      Number(lebDecode(new PipeArrayBuffer(lookupTime))) / 1_000_000;\n    const expiry = certificateTime - now + MAX_AGE_IN_MINUTES * 60 * 1000;\n    setTimeout(() => this.#certificates.delete(requestKey), expiry);\n\n    // Return request id with http response\n    return {\n      requestId,\n      response: {\n        ok: true,\n        status: 202,\n        statusText: \"Call has been sent over ICRC-25 JSON-RPC\",\n        body: null,\n        headers: [],\n      },\n    };\n  }\n\n  async fetchRootKey(): Promise<ArrayBuffer> {\n    return this.#options.agent.fetchRootKey();\n  }\n\n  async getPrincipal(): Promise<Principal> {\n    return this.#options.account;\n  }\n\n  async query(\n    canisterId: Principal | string,\n    options: QueryFields,\n  ): Promise<ApiQueryResponse> {\n    // Make sure canisterId is a principal\n    canisterId = Principal.from(canisterId);\n\n    // Upgrade query request to a call sent through signer\n    const submitResponse = await this.call(canisterId, options);\n    const readStateResponse = await this.readState(canisterId, {\n      paths: [\n        [new TextEncoder().encode(\"request_status\"), submitResponse.requestId],\n      ],\n    });\n    const certificate = await Certificate.create({\n      certificate: readStateResponse.certificate,\n      rootKey: this.rootKey,\n      canisterId,\n    });\n    const status = certificate.lookup([\n      \"request_status\",\n      submitResponse.requestId,\n      \"status\",\n    ]);\n    const reply = certificate.lookup([\n      \"request_status\",\n      submitResponse.requestId,\n      \"reply\",\n    ]);\n    if (\n      status.status !== LookupStatus.Found ||\n      new TextDecoder().decode(status.value as ArrayBuffer) !== \"replied\" ||\n      reply.status !== LookupStatus.Found\n    ) {\n      throw new SignerAgentError(\"Certificate is missing reply\");\n    }\n    return {\n      requestId: submitResponse.requestId,\n      status: \"replied\" as QueryResponseStatus.Replied,\n      reply: {\n        arg: reply.value as ArrayBuffer,\n      },\n      httpDetails: {\n        ok: true,\n        status: 202,\n        statusText:\n          \"Certificate with reply has been received over ICRC-25 JSON-RPC\",\n        headers: [],\n      },\n    };\n  }\n\n  async createReadStateRequest(\n    _options: ReadStateOptions,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    // Since request is typed as any it shouldn't need any data,\n    // but since agent-js 2.1.3 this would cause a runtime error.\n    return {\n      body: {\n        content: {},\n      },\n    };\n  }\n\n  async readState(\n    _canisterId: Principal | string,\n    options: ReadStateOptions,\n    _identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _request?: any,\n  ): Promise<ReadStateResponse> {\n    if (\n      options.paths.length !== 1 ||\n      options.paths[0].length !== 2 ||\n      new TextDecoder().decode(options.paths[0][0]) !== \"request_status\"\n    ) {\n      throw new SignerAgentError(\"Given paths are not supported\");\n    }\n    const requestId = options.paths[0][1] as RequestId;\n    const key = toBase64(requestId);\n    const certificate = this.#certificates.get(key);\n    if (!certificate) {\n      throw new SignerAgentError(\"Certificate could not be found\");\n    }\n    return { certificate };\n  }\n\n  async status(): Promise<JsonObject> {\n    return this.#options.agent.status();\n  }\n\n  replaceAccount(account: Principal) {\n    this.#options.account = account;\n  }\n}\n"]}