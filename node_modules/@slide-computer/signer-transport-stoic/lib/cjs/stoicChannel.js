"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _StoicChannel_instances, _StoicChannel_connection, _StoicChannel_agent, _StoicChannel_closeListeners, _StoicChannel_responseListeners, _StoicChannel_closed, _StoicChannel_createResponse;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoicChannel = void 0;
const signer_1 = require("@slide-computer/signer");
const stoicTransport_1 = require("./stoicTransport");
const constants_1 = require("./constants");
const identity_1 = require("@dfinity/identity");
const agent_1 = require("@dfinity/agent");
const principal_1 = require("@dfinity/principal");
class StoicChannel {
    constructor(connection, agent) {
        _StoicChannel_instances.add(this);
        _StoicChannel_connection.set(this, void 0);
        _StoicChannel_agent.set(this, void 0);
        _StoicChannel_closeListeners.set(this, new Set());
        _StoicChannel_responseListeners.set(this, new Set());
        _StoicChannel_closed.set(this, false);
        __classPrivateFieldSet(this, _StoicChannel_connection, connection, "f");
        __classPrivateFieldSet(this, _StoicChannel_agent, agent, "f");
        __classPrivateFieldGet(this, _StoicChannel_connection, "f").addEventListener("disconnect", () => (__classPrivateFieldSet(this, _StoicChannel_closed, true, "f")));
    }
    get closed() {
        return __classPrivateFieldGet(this, _StoicChannel_closed, "f") || !__classPrivateFieldGet(this, _StoicChannel_connection, "f").connected;
    }
    addEventListener(...[event, listener]) {
        switch (event) {
            case "close":
                __classPrivateFieldGet(this, _StoicChannel_closeListeners, "f").add(listener);
                return () => {
                    __classPrivateFieldGet(this, _StoicChannel_closeListeners, "f").delete(listener);
                };
            case "response":
                __classPrivateFieldGet(this, _StoicChannel_responseListeners, "f").add(listener);
                return () => {
                    __classPrivateFieldGet(this, _StoicChannel_responseListeners, "f").delete(listener);
                };
        }
    }
    async send(request) {
        if (this.closed) {
            throw new stoicTransport_1.StoicTransportError("Communication channel is closed");
        }
        // Ignore one way messages
        const id = request.id;
        if (id === undefined) {
            return;
        }
        // Create response and call listeners
        const response = await __classPrivateFieldGet(this, _StoicChannel_instances, "m", _StoicChannel_createResponse).call(this, Object.assign({ id }, request));
        __classPrivateFieldGet(this, _StoicChannel_responseListeners, "f").forEach((listener) => listener(response));
    }
    async close() {
        __classPrivateFieldSet(this, _StoicChannel_closed, true, "f");
        __classPrivateFieldGet(this, _StoicChannel_closeListeners, "f").forEach((listener) => listener());
    }
}
exports.StoicChannel = StoicChannel;
_StoicChannel_connection = new WeakMap(), _StoicChannel_agent = new WeakMap(), _StoicChannel_closeListeners = new WeakMap(), _StoicChannel_responseListeners = new WeakMap(), _StoicChannel_closed = new WeakMap(), _StoicChannel_instances = new WeakSet(), _StoicChannel_createResponse = async function _StoicChannel_createResponse(request) {
    var _a, _b, _c, _d;
    const id = request.id;
    if (!(0, signer_1.isJsonRpcRequest)(request)) {
        return {
            id,
            jsonrpc: "2.0",
            error: { code: signer_1.INVALID_REQUEST_ERROR, message: "Invalid request" },
        };
    }
    switch (request.method) {
        case "icrc25_supported_standards":
            return {
                id,
                jsonrpc: "2.0",
                result: { supportedStandards: constants_1.supportedStandards },
            };
        case "icrc25_permissions":
        case "icrc25_request_permissions":
            return {
                id,
                jsonrpc: "2.0",
                result: { scopes: constants_1.scopes },
            };
        case "icrc27_accounts":
            const owner = principal_1.Principal.selfAuthenticating(new Uint8Array(__classPrivateFieldGet(this, _StoicChannel_connection, "f").delegationChain.publicKey)).toText();
            return {
                id,
                jsonrpc: "2.0",
                result: {
                    accounts: Array.from({
                        length: (_a = __classPrivateFieldGet(this, _StoicChannel_connection, "f").accounts) !== null && _a !== void 0 ? _a : 0,
                    }).map((_, index) => {
                        const buffer = new ArrayBuffer(32);
                        new DataView(buffer).setBigUint64(24, BigInt(index), false);
                        return {
                            owner,
                            subaccount: (0, signer_1.toBase64)(buffer),
                        };
                    }),
                },
            };
        case "icrc34_delegation":
            const delegationRequest = request;
            const identity = __classPrivateFieldGet(this, _StoicChannel_connection, "f").identity;
            const delegationChain = __classPrivateFieldGet(this, _StoicChannel_connection, "f").delegationChain;
            const expiration = new Date(Date.now() +
                Number(delegationRequest.params.maxTimeToLive
                    ? BigInt(delegationRequest.params.maxTimeToLive) /
                        BigInt(1000000)
                    : BigInt(8) * BigInt(3600000)));
            const signedDelegationChain = await identity_1.DelegationChain.create(identity, { toDer: () => (0, signer_1.fromBase64)(delegationRequest.params.publicKey) }, expiration, {
                previous: delegationChain,
                targets: (_b = delegationRequest.params.targets) === null || _b === void 0 ? void 0 : _b.map((target) => principal_1.Principal.fromText(target)),
            });
            return {
                id,
                jsonrpc: "2.0",
                result: {
                    publicKey: (0, signer_1.toBase64)(signedDelegationChain.publicKey),
                    signerDelegation: signedDelegationChain.delegations.map(({ delegation, signature }) => ({
                        delegation: Object.assign({ pubkey: (0, signer_1.toBase64)(delegation.pubkey), expiration: delegation.expiration.toString() }, (delegation.targets
                            ? {
                                targets: delegation.targets.map((target) => target.toText()),
                            }
                            : {})),
                        signature: (0, signer_1.toBase64)(signature),
                    })),
                },
            };
        case "icrc49_call_canister":
            const callCanisterRequest = request;
            const { pollForResponse, defaultStrategy } = agent_1.polling;
            const canisterId = principal_1.Principal.fromText(callCanisterRequest.params.canisterId);
            const delegationIdentity = identity_1.DelegationIdentity.fromDelegation(__classPrivateFieldGet(this, _StoicChannel_connection, "f").identity, __classPrivateFieldGet(this, _StoicChannel_connection, "f").delegationChain);
            if (((_c = callCanisterRequest.params) === null || _c === void 0 ? void 0 : _c.sender) !==
                delegationIdentity.getPrincipal().toString()) {
                throw new stoicTransport_1.StoicTransportError("Sender does not match Stoic identity");
            }
            const agent = await agent_1.HttpAgent.from((_d = __classPrivateFieldGet(this, _StoicChannel_agent, "f")) !== null && _d !== void 0 ? _d : (await agent_1.HttpAgent.create()));
            agent.replaceIdentity(delegationIdentity);
            let contentMap;
            agent.addTransform("update", async (agentRequest) => {
                contentMap = agent_1.Cbor.encode(agentRequest.body);
                return agentRequest;
            });
            const submitResponse = await agent.call(canisterId, {
                effectiveCanisterId: canisterId,
                methodName: callCanisterRequest.params.method,
                arg: (0, signer_1.fromBase64)(callCanisterRequest.params.arg),
            });
            await pollForResponse(agent, canisterId, submitResponse.requestId, defaultStrategy());
            const { certificate } = await agent.readState(canisterId, {
                paths: [
                    [
                        new TextEncoder().encode("request_status"),
                        submitResponse.requestId,
                    ],
                ],
            });
            return {
                id,
                jsonrpc: "2.0",
                result: {
                    contentMap: (0, signer_1.toBase64)(contentMap),
                    certificate: (0, signer_1.toBase64)(certificate),
                },
            };
        default:
            return {
                id,
                jsonrpc: "2.0",
                error: { code: signer_1.NOT_SUPPORTED_ERROR, message: "Not supported" },
            };
    }
};
//# sourceMappingURL=stoicChannel.js.map