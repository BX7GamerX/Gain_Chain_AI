import { Principal } from "@dfinity/principal";
import { DelegationChain } from "@dfinity/identity";
import type { JsonValue } from "@dfinity/candid";
import type { Channel, JsonError, JsonRequest, JsonResponse, Transport } from "./transport";
import type { PermissionScope, PermissionState, SupportedStandard } from "./icrc25";
import type { AccountsPermissionScope } from "./icrc27";
import type { DelegationPermissionScope } from "./icrc34";
import type { CallCanisterPermissionScope } from "./icrc49";
export declare class SignerError extends Error {
    code: number;
    data?: JsonValue;
    constructor(error: JsonError);
}
export type SignerPermissionScope = PermissionScope | AccountsPermissionScope | DelegationPermissionScope | CallCanisterPermissionScope;
export interface SignerOptions<T extends Transport> {
    /**
     * The transport used to send and receive messages
     */
    transport: T;
    /**
     * Automatically close transport channel after response has been received
     * @default true
     */
    autoCloseTransportChannel?: boolean;
    /**
     * Close transport channel after a given duration in ms
     * @default 200
     */
    closeTransportChannelAfter?: number;
    /**
     * Get random uuid implementation for request message ids
     * @default globalThis.crypto
     */
    crypto?: Pick<Crypto, "randomUUID">;
    /**
     * Origin to use to derive identity
     */
    derivationOrigin?: string;
}
export declare class Signer<T extends Transport = Transport> {
    #private;
    constructor(options: SignerOptions<T>);
    get transport(): T;
    openChannel(): Promise<Channel>;
    closeChannel(): Promise<void>;
    transformRequest<T extends JsonRequest>(request: T): Promise<T>;
    sendRequest<T extends JsonRequest, S extends JsonResponse>(request: T): Promise<S>;
    supportedStandards(): Promise<SupportedStandard[]>;
    requestPermissions(scopes: SignerPermissionScope[]): Promise<Array<{
        scope: SignerPermissionScope;
        state: PermissionState;
    }>>;
    permissions(): Promise<Array<{
        scope: SignerPermissionScope;
        state: PermissionState;
    }>>;
    accounts(): Promise<Array<{
        owner: Principal;
        subaccount?: ArrayBuffer;
    }>>;
    delegation(params: {
        publicKey: ArrayBuffer;
        targets?: Principal[];
        maxTimeToLive?: bigint;
    }): Promise<DelegationChain>;
    callCanister(params: {
        canisterId: Principal;
        sender: Principal;
        method: string;
        arg: ArrayBuffer;
    }): Promise<{
        contentMap: ArrayBuffer;
        certificate: ArrayBuffer;
    }>;
}
