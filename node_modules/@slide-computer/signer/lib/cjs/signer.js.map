{"version":3,"file":"signer.js","sourceRoot":"","sources":["../../src/signer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Principal } from \"@dfinity/principal\";\nimport { Delegation, DelegationChain } from \"@dfinity/identity\";\nimport { type Signature } from \"@dfinity/agent\";\nimport type { JsonValue } from \"@dfinity/candid\";\nimport type {\n  Channel,\n  JsonError,\n  JsonRequest,\n  JsonResponse,\n  Transport,\n} from \"./transport\";\nimport type {\n  PermissionScope,\n  PermissionsRequest,\n  PermissionsResponse,\n  PermissionState,\n  RequestPermissionsRequest,\n  RequestPermissionsResponse,\n  SupportedStandard,\n  SupportedStandardsRequest,\n  SupportedStandardsResponse,\n} from \"./icrc25\";\nimport type {\n  AccountsPermissionScope,\n  AccountsRequest,\n  AccountsResponse,\n} from \"./icrc27\";\nimport type {\n  DelegationPermissionScope,\n  DelegationRequest,\n  DelegationResponse,\n} from \"./icrc34\";\nimport type {\n  CallCanisterPermissionScope,\n  CallCanisterRequest,\n  CallCanisterResponse,\n} from \"./icrc49\";\nimport { NETWORK_ERROR } from \"./errors\";\nimport { fromBase64, toBase64 } from \"./utils\";\n\nexport class SignerError extends Error {\n  public code: number;\n  public data?: JsonValue;\n\n  constructor(error: JsonError) {\n    super(error.message);\n    Object.setPrototypeOf(this, SignerError.prototype);\n\n    this.code = error.code;\n    this.data = error.data;\n  }\n}\n\nconst wrapTransportError = (error: unknown) =>\n  new SignerError({\n    code: NETWORK_ERROR,\n    message: error instanceof Error ? error.message : \"Network error\",\n  });\n\nconst unwrapResponse = <T extends JsonValue>(response: JsonResponse<T>): T => {\n  if (\"error\" in response) {\n    throw new SignerError(response.error);\n  }\n  if (\"result\" in response) {\n    return response.result;\n  }\n  throw new SignerError({\n    code: NETWORK_ERROR,\n    message: \"Invalid response\",\n  });\n};\n\nexport type SignerPermissionScope =\n  | PermissionScope\n  | AccountsPermissionScope\n  | DelegationPermissionScope\n  | CallCanisterPermissionScope;\n\nexport interface SignerOptions<T extends Transport> {\n  /**\n   * The transport used to send and receive messages\n   */\n  transport: T;\n  /**\n   * Automatically close transport channel after response has been received\n   * @default true\n   */\n  autoCloseTransportChannel?: boolean;\n  /**\n   * Close transport channel after a given duration in ms\n   * @default 200\n   */\n  closeTransportChannelAfter?: number;\n  /**\n   * Get random uuid implementation for request message ids\n   * @default globalThis.crypto\n   */\n  crypto?: Pick<Crypto, \"randomUUID\">;\n  /**\n   * Origin to use to derive identity\n   */\n  derivationOrigin?: string;\n}\n\nexport class Signer<T extends Transport = Transport> {\n  readonly #options: Required<Omit<SignerOptions<T>, \"derivationOrigin\">> &\n    Pick<SignerOptions<T>, \"derivationOrigin\">;\n  #channel?: Channel;\n  #establishingChannel?: Promise<void>;\n  #scheduledChannelClosure?: ReturnType<typeof setTimeout>;\n\n  constructor(options: SignerOptions<T>) {\n    this.#options = {\n      autoCloseTransportChannel: true,\n      closeTransportChannelAfter: 200,\n      crypto: globalThis.crypto,\n      ...options,\n    };\n  }\n\n  get transport(): T {\n    return this.#options.transport;\n  }\n\n  async openChannel(): Promise<Channel> {\n    // Stop any existing channel from being closed\n    clearTimeout(this.#scheduledChannelClosure);\n\n    // Wait for ongoing establishing of a channel\n    if (this.#establishingChannel) {\n      await this.#establishingChannel;\n    }\n\n    // Reuse existing channel\n    if (this.#channel && !this.#channel.closed) {\n      return this.#channel;\n    }\n\n    // Establish a new transport channel\n    const channel = this.#options.transport.establishChannel();\n    // Indicate that transport channel is being established\n    this.#establishingChannel = channel.then(() => {}).catch(() => {});\n    // Clear previous transport channel\n    this.#channel = undefined;\n    // Assign transport channel once established\n    this.#channel = await channel.catch((error) => {\n      throw wrapTransportError(error);\n    });\n    // Remove transport channel being established indicator\n    this.#establishingChannel = undefined;\n    // Return established channel\n    return this.#channel;\n  }\n\n  async closeChannel(): Promise<void> {\n    await this.#channel?.close();\n  }\n\n  async transformRequest<T extends JsonRequest>(request: T): Promise<T> {\n    if (this.#options.derivationOrigin) {\n      return {\n        ...request,\n        params: {\n          ...request.params,\n          icrc95DerivationOrigin: this.#options.derivationOrigin,\n        },\n      };\n    }\n    return request;\n  }\n\n  async sendRequest<T extends JsonRequest, S extends JsonResponse>(\n    request: T,\n  ): Promise<S> {\n    // Establish new or re-use existing transport channel\n    const channel = await this.openChannel();\n\n    return new Promise<S>(async (resolve, reject) => {\n      // Listen on transport channel for incoming response\n      const responseListener = channel.addEventListener(\n        \"response\",\n        async (response) => {\n          if (response.id !== request.id) {\n            // Ignore responses that don't match the request id\n            return;\n          }\n\n          // Stop listening to events once a valid response has been received\n          responseListener();\n          closeListener();\n\n          // Return response\n          resolve(response as S);\n\n          // Close transport channel after a certain timeout\n          if (this.#options.autoCloseTransportChannel) {\n            this.#scheduledChannelClosure = setTimeout(() => {\n              if (!channel.closed) {\n                channel.close();\n              }\n            }, this.#options.closeTransportChannelAfter);\n          }\n        },\n      );\n\n      // Monitor if channel is closed before a response has been received\n      const closeListener = channel.addEventListener(\"close\", () => {\n        // Stop listening to events once a channel is closed\n        responseListener();\n        closeListener();\n\n        // Throw error if channel is closed before response is received\n        reject(\n          new SignerError({\n            code: NETWORK_ERROR,\n            message: \"Channel was closed before a response was received\",\n          }),\n        );\n      });\n\n      // Send outgoing request over transport channel\n      try {\n        await channel.send(await this.transformRequest(request));\n      } catch (error) {\n        responseListener();\n        closeListener();\n        reject(wrapTransportError(error));\n      }\n    });\n  }\n\n  async supportedStandards(): Promise<SupportedStandard[]> {\n    const response = await this.sendRequest<\n      SupportedStandardsRequest,\n      SupportedStandardsResponse\n    >({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc25_supported_standards\",\n    });\n    const result = unwrapResponse(response);\n    return result.supportedStandards;\n  }\n\n  async requestPermissions(\n    scopes: SignerPermissionScope[],\n  ): Promise<Array<{ scope: SignerPermissionScope; state: PermissionState }>> {\n    const response = await this.sendRequest<\n      RequestPermissionsRequest,\n      RequestPermissionsResponse\n    >({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc25_request_permissions\",\n      params: { scopes },\n    });\n    const result = unwrapResponse(response);\n    return result.scopes;\n  }\n\n  async permissions(): Promise<\n    Array<{ scope: SignerPermissionScope; state: PermissionState }>\n  > {\n    const response = await this.sendRequest<\n      PermissionsRequest,\n      PermissionsResponse\n    >({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc25_permissions\",\n    });\n    const result = unwrapResponse(response);\n    return result.scopes;\n  }\n\n  async accounts(): Promise<\n    Array<{ owner: Principal; subaccount?: ArrayBuffer }>\n  > {\n    const response = await this.sendRequest<AccountsRequest, AccountsResponse>({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc27_accounts\",\n    });\n    const result = unwrapResponse(response);\n    return result.accounts.map(({ owner, subaccount }) => ({\n      owner: Principal.fromText(owner),\n      subaccount: subaccount === undefined ? undefined : fromBase64(subaccount),\n    }));\n  }\n\n  async delegation(params: {\n    publicKey: ArrayBuffer;\n    targets?: Principal[];\n    maxTimeToLive?: bigint;\n  }): Promise<DelegationChain> {\n    const response = await this.sendRequest<\n      DelegationRequest,\n      DelegationResponse\n    >({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc34_delegation\",\n      params: {\n        publicKey: toBase64(params.publicKey),\n        targets: params.targets?.map((p) => p.toText()),\n        maxTimeToLive:\n          params.maxTimeToLive === undefined\n            ? undefined\n            : String(params.maxTimeToLive),\n      },\n    });\n    const result = unwrapResponse(response);\n    return DelegationChain.fromDelegations(\n      result.signerDelegation.map((delegation) => ({\n        delegation: new Delegation(\n          fromBase64(delegation.delegation.pubkey),\n          BigInt(delegation.delegation.expiration),\n          delegation.delegation.targets?.map((principal) =>\n            Principal.fromText(principal),\n          ),\n        ),\n        signature: fromBase64(delegation.signature) as Signature,\n      })),\n      fromBase64(result.publicKey),\n    );\n  }\n\n  async callCanister(params: {\n    canisterId: Principal;\n    sender: Principal;\n    method: string;\n    arg: ArrayBuffer;\n  }): Promise<{ contentMap: ArrayBuffer; certificate: ArrayBuffer }> {\n    const response = await this.sendRequest<\n      CallCanisterRequest,\n      CallCanisterResponse\n    >({\n      id: this.#options.crypto.randomUUID(),\n      jsonrpc: \"2.0\",\n      method: \"icrc49_call_canister\",\n      params: {\n        canisterId: params.canisterId.toText(),\n        sender: params.sender.toText(),\n        method: params.method,\n        arg: toBase64(params.arg),\n      },\n    });\n    const result = unwrapResponse(response);\n    const contentMap = fromBase64(result.contentMap);\n    const certificate = fromBase64(result.certificate);\n    return { contentMap, certificate };\n  }\n}\n"]}