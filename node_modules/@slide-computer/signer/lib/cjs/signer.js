"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Signer_options, _Signer_channel, _Signer_establishingChannel, _Signer_scheduledChannelClosure;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = exports.SignerError = void 0;
const principal_1 = require("@dfinity/principal");
const identity_1 = require("@dfinity/identity");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
class SignerError extends Error {
    constructor(error) {
        super(error.message);
        Object.setPrototypeOf(this, SignerError.prototype);
        this.code = error.code;
        this.data = error.data;
    }
}
exports.SignerError = SignerError;
const wrapTransportError = (error) => new SignerError({
    code: errors_1.NETWORK_ERROR,
    message: error instanceof Error ? error.message : "Network error",
});
const unwrapResponse = (response) => {
    if ("error" in response) {
        throw new SignerError(response.error);
    }
    if ("result" in response) {
        return response.result;
    }
    throw new SignerError({
        code: errors_1.NETWORK_ERROR,
        message: "Invalid response",
    });
};
class Signer {
    constructor(options) {
        _Signer_options.set(this, void 0);
        _Signer_channel.set(this, void 0);
        _Signer_establishingChannel.set(this, void 0);
        _Signer_scheduledChannelClosure.set(this, void 0);
        __classPrivateFieldSet(this, _Signer_options, Object.assign({ autoCloseTransportChannel: true, closeTransportChannelAfter: 200, crypto: globalThis.crypto }, options), "f");
    }
    get transport() {
        return __classPrivateFieldGet(this, _Signer_options, "f").transport;
    }
    async openChannel() {
        // Stop any existing channel from being closed
        clearTimeout(__classPrivateFieldGet(this, _Signer_scheduledChannelClosure, "f"));
        // Wait for ongoing establishing of a channel
        if (__classPrivateFieldGet(this, _Signer_establishingChannel, "f")) {
            await __classPrivateFieldGet(this, _Signer_establishingChannel, "f");
        }
        // Reuse existing channel
        if (__classPrivateFieldGet(this, _Signer_channel, "f") && !__classPrivateFieldGet(this, _Signer_channel, "f").closed) {
            return __classPrivateFieldGet(this, _Signer_channel, "f");
        }
        // Establish a new transport channel
        const channel = __classPrivateFieldGet(this, _Signer_options, "f").transport.establishChannel();
        // Indicate that transport channel is being established
        __classPrivateFieldSet(this, _Signer_establishingChannel, channel.then(() => { }).catch(() => { }), "f");
        // Clear previous transport channel
        __classPrivateFieldSet(this, _Signer_channel, undefined, "f");
        // Assign transport channel once established
        __classPrivateFieldSet(this, _Signer_channel, await channel.catch((error) => {
            throw wrapTransportError(error);
        }), "f");
        // Remove transport channel being established indicator
        __classPrivateFieldSet(this, _Signer_establishingChannel, undefined, "f");
        // Return established channel
        return __classPrivateFieldGet(this, _Signer_channel, "f");
    }
    async closeChannel() {
        var _a;
        await ((_a = __classPrivateFieldGet(this, _Signer_channel, "f")) === null || _a === void 0 ? void 0 : _a.close());
    }
    async transformRequest(request) {
        if (__classPrivateFieldGet(this, _Signer_options, "f").derivationOrigin) {
            return Object.assign(Object.assign({}, request), { params: Object.assign(Object.assign({}, request.params), { icrc95DerivationOrigin: __classPrivateFieldGet(this, _Signer_options, "f").derivationOrigin }) });
        }
        return request;
    }
    async sendRequest(request) {
        // Establish new or re-use existing transport channel
        const channel = await this.openChannel();
        return new Promise(async (resolve, reject) => {
            // Listen on transport channel for incoming response
            const responseListener = channel.addEventListener("response", async (response) => {
                if (response.id !== request.id) {
                    // Ignore responses that don't match the request id
                    return;
                }
                // Stop listening to events once a valid response has been received
                responseListener();
                closeListener();
                // Return response
                resolve(response);
                // Close transport channel after a certain timeout
                if (__classPrivateFieldGet(this, _Signer_options, "f").autoCloseTransportChannel) {
                    __classPrivateFieldSet(this, _Signer_scheduledChannelClosure, setTimeout(() => {
                        if (!channel.closed) {
                            channel.close();
                        }
                    }, __classPrivateFieldGet(this, _Signer_options, "f").closeTransportChannelAfter), "f");
                }
            });
            // Monitor if channel is closed before a response has been received
            const closeListener = channel.addEventListener("close", () => {
                // Stop listening to events once a channel is closed
                responseListener();
                closeListener();
                // Throw error if channel is closed before response is received
                reject(new SignerError({
                    code: errors_1.NETWORK_ERROR,
                    message: "Channel was closed before a response was received",
                }));
            });
            // Send outgoing request over transport channel
            try {
                await channel.send(await this.transformRequest(request));
            }
            catch (error) {
                responseListener();
                closeListener();
                reject(wrapTransportError(error));
            }
        });
    }
    async supportedStandards() {
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc25_supported_standards",
        });
        const result = unwrapResponse(response);
        return result.supportedStandards;
    }
    async requestPermissions(scopes) {
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc25_request_permissions",
            params: { scopes },
        });
        const result = unwrapResponse(response);
        return result.scopes;
    }
    async permissions() {
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc25_permissions",
        });
        const result = unwrapResponse(response);
        return result.scopes;
    }
    async accounts() {
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc27_accounts",
        });
        const result = unwrapResponse(response);
        return result.accounts.map(({ owner, subaccount }) => ({
            owner: principal_1.Principal.fromText(owner),
            subaccount: subaccount === undefined ? undefined : (0, utils_1.fromBase64)(subaccount),
        }));
    }
    async delegation(params) {
        var _a;
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc34_delegation",
            params: {
                publicKey: (0, utils_1.toBase64)(params.publicKey),
                targets: (_a = params.targets) === null || _a === void 0 ? void 0 : _a.map((p) => p.toText()),
                maxTimeToLive: params.maxTimeToLive === undefined
                    ? undefined
                    : String(params.maxTimeToLive),
            },
        });
        const result = unwrapResponse(response);
        return identity_1.DelegationChain.fromDelegations(result.signerDelegation.map((delegation) => {
            var _a;
            return ({
                delegation: new identity_1.Delegation((0, utils_1.fromBase64)(delegation.delegation.pubkey), BigInt(delegation.delegation.expiration), (_a = delegation.delegation.targets) === null || _a === void 0 ? void 0 : _a.map((principal) => principal_1.Principal.fromText(principal))),
                signature: (0, utils_1.fromBase64)(delegation.signature),
            });
        }), (0, utils_1.fromBase64)(result.publicKey));
    }
    async callCanister(params) {
        const response = await this.sendRequest({
            id: __classPrivateFieldGet(this, _Signer_options, "f").crypto.randomUUID(),
            jsonrpc: "2.0",
            method: "icrc49_call_canister",
            params: {
                canisterId: params.canisterId.toText(),
                sender: params.sender.toText(),
                method: params.method,
                arg: (0, utils_1.toBase64)(params.arg),
            },
        });
        const result = unwrapResponse(response);
        const contentMap = (0, utils_1.fromBase64)(result.contentMap);
        const certificate = (0, utils_1.fromBase64)(result.certificate);
        return { contentMap, certificate };
    }
}
exports.Signer = Signer;
_Signer_options = new WeakMap(), _Signer_channel = new WeakMap(), _Signer_establishingChannel = new WeakMap(), _Signer_scheduledChannelClosure = new WeakMap();
//# sourceMappingURL=signer.js.map